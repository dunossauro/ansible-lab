{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Laborat\u00f3rio para Live de Python sobre Ansible O objetivo desse reposit\u00f3rio \u00e9 ajudar voc\u00ea a construir um laborat\u00f3rio para aprender Ansible. Aqui voc\u00ea vai encontrar dicas e passos para configurar suas m\u00e1quinas virtuais para construir seu ambiente. A minha ideia principal com essa live \u00e9 n\u00e3o depender de nenhum servi\u00e7o de nuvem. Nem todas as pessoas podem pagar ou tem cart\u00e3o de cr\u00e9dito para poder inserir mesmo nos planos gratuitos. Para n\u00e3o depender de servi\u00e7os externos, vamos usar m\u00e1quinas virtuais com virtualbox e vamos configur\u00e1-las usando Vagrant . Sum\u00e1rio 01 - Configura\u00e7\u00e3o do ambiente 02 - O b\u00e1sico necess\u00e1rio sobre Vagrant 03 - Ansible b\u00e1sico 04 - Entendendo a estrutura do Ansible 05 - Playbooks","title":"Laborat\u00f3rio para Live de Python sobre Ansible :snake:"},{"location":"#laboratorio-para-live-de-python-sobre-ansible","text":"O objetivo desse reposit\u00f3rio \u00e9 ajudar voc\u00ea a construir um laborat\u00f3rio para aprender Ansible. Aqui voc\u00ea vai encontrar dicas e passos para configurar suas m\u00e1quinas virtuais para construir seu ambiente. A minha ideia principal com essa live \u00e9 n\u00e3o depender de nenhum servi\u00e7o de nuvem. Nem todas as pessoas podem pagar ou tem cart\u00e3o de cr\u00e9dito para poder inserir mesmo nos planos gratuitos. Para n\u00e3o depender de servi\u00e7os externos, vamos usar m\u00e1quinas virtuais com virtualbox e vamos configur\u00e1-las usando Vagrant .","title":"Laborat\u00f3rio para Live de Python sobre Ansible"},{"location":"#sumario","text":"01 - Configura\u00e7\u00e3o do ambiente 02 - O b\u00e1sico necess\u00e1rio sobre Vagrant 03 - Ansible b\u00e1sico 04 - Entendendo a estrutura do Ansible 05 - Playbooks","title":"Sum\u00e1rio"},{"location":"01_configuracao_do_ambiente/","text":"Configura\u00e7\u00e3o do ambiente A primeira coisa que precisamos fazer \u00e9 configurar o nosso host para instala\u00e7\u00e3o das m\u00e1quinas virtuais. Para isso, precisamos instalar o virtualbox e o vagrant . Instala\u00e7\u00e3o do virtualbox Virtualbox \u00e9 um software para cria\u00e7\u00e3o de m\u00e1quinas virtuais. E ele pode ser instalado em qualquer plataforma comum do mercado. Como Windows, Linux e MacOS. Caso voc\u00ea use o windows, as instala\u00e7\u00f5es podem ser feitas via chocolatey Voc\u00ea pode fazer o download e instalar ou instalar usando o seu gerenciador de pacotes usando seu terminal preferido: paru -S virtualbox # Arch choco install virtualbox # Windows sudo apt-get install virtualbox # Ubuntu Instala\u00e7\u00e3o do vagrant Vagrant \u00e9 um software de c\u00f3digo aberto, escrito em Ruby para construir ambientes de desenvolvimento usando um arquivo de configura\u00e7\u00e3o. Que pode ser reproduzido por qualquer pessoa que tenha acesso ao arquivo. Abra seu terminal preferido e fa\u00e7a a instala\u00e7\u00e3o: paru -S vagrant # Arch choco install vagrant # Windows sudo apt install vagrant # Ubuntu","title":"Configura\u00e7\u00e3o do ambiente"},{"location":"01_configuracao_do_ambiente/#configuracao-do-ambiente","text":"A primeira coisa que precisamos fazer \u00e9 configurar o nosso host para instala\u00e7\u00e3o das m\u00e1quinas virtuais. Para isso, precisamos instalar o virtualbox e o vagrant .","title":"Configura\u00e7\u00e3o do ambiente"},{"location":"01_configuracao_do_ambiente/#instalacao-do-virtualbox","text":"Virtualbox \u00e9 um software para cria\u00e7\u00e3o de m\u00e1quinas virtuais. E ele pode ser instalado em qualquer plataforma comum do mercado. Como Windows, Linux e MacOS. Caso voc\u00ea use o windows, as instala\u00e7\u00f5es podem ser feitas via chocolatey Voc\u00ea pode fazer o download e instalar ou instalar usando o seu gerenciador de pacotes usando seu terminal preferido: paru -S virtualbox # Arch choco install virtualbox # Windows sudo apt-get install virtualbox # Ubuntu","title":"Instala\u00e7\u00e3o do virtualbox"},{"location":"01_configuracao_do_ambiente/#instalacao-do-vagrant","text":"Vagrant \u00e9 um software de c\u00f3digo aberto, escrito em Ruby para construir ambientes de desenvolvimento usando um arquivo de configura\u00e7\u00e3o. Que pode ser reproduzido por qualquer pessoa que tenha acesso ao arquivo. Abra seu terminal preferido e fa\u00e7a a instala\u00e7\u00e3o: paru -S vagrant # Arch choco install vagrant # Windows sudo apt install vagrant # Ubuntu","title":"Instala\u00e7\u00e3o do vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/","text":"B\u00e1sico necess\u00e1rio sobre Vagrant Vagrant \u00e9 uma ferramenta para provisionamento de m\u00e1quinas virtuais. Dizendo de forma simples, ele cria e configura m\u00e1quinas virtuais usando um arquivo de configura\u00e7\u00e3o chamado Vagrantfile . Nesse arquivo podemos descrever como nossas vms ser\u00e3o configuradas. Exemplo de um arquivo do Vagrant: Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end A linha destacada \u00e9 referente a um box do Vagrant. Vagrant boxes Um box do vagrant no nosso contexto \u00e9 uma m\u00e1quina virtual pr\u00e9-fabricada por uma pessoa. Existem milhares delas e elas podem ser acessadas no Vagrant Cloud Eu optei por usar m\u00e1quina do arch linux para iniciarmos nossa configura\u00e7\u00e3o. Criando uma m\u00e1quina virtual Nosso primeiro passado \u00e9 copiar o seguinte Vagrantfile : Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end e colocar no diret\u00f3rio do nosso projeto. Que vamos inicialmente chamar de ansible-lab . Dessa forma podemos criar nossa m\u00e1quina virtual usando um simples comando: $ Execu\u00e7\u00e3o no terminal vagrant up O resultado deve ser algo parecido com isso: Bringing machine 'default' up with 'virtualbox' provider... == > default: Importing base box 'archlinux/archlinux' ... == > default: Matching MAC address for NAT networking... == > default: Checking if box 'archlinux/archlinux' version '20221101.99038' is up to date... == > default: Setting the name of the VM: ansible_lab_default_1668393945684_70462 == > default: Clearing any previously set network interfaces... == > default: Preparing network interfaces based on configuration... default: Adapter 1 : nat == > default: Forwarding ports... default: 22 ( guest ) = > 2222 ( host ) ( adapter 1 ) == > default: Booting VM... == > default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127 .0.0.1:2222 default: SSH username: vagrant default: SSH auth method: private key default: Warning: Connection reset. Retrying... default: Warning: Remote connection disconnect. Retrying... default: default: Vagrant insecure key detected. Vagrant will automatically replace default: this with a newly generated keypair for better security. default: default: Inserting generated public key within guest... default: Removing insecure key from the guest if it ' s present... default: Key inserted! Disconnecting and reconnecting using new SSH key... == > default: Machine booted and ready! == > default: Checking for guest additions in VM... == > default: Mounting shared folders... default: /vagrant = > /home/z4r4tu5tr4/ansible_lab E ele criar\u00e1 uma m\u00e1quina virtual com archlinux no nosso virtualbox. OBS: Esse comando pode demorar um pouco pois ele vai baixar um hd virtual do archlinux e instalar no seu virtualbox. Agora que temos uma m\u00e1quina virtual podemos partir para o segundo passo. Que \u00e9 criar dois n\u00f3s para trabalhar com ansible. Destruindo a m\u00e1quina criada Caso voc\u00ea tenha problemas ou queira simplesmente destruir a m\u00e1quina virutal. O vagrant pode destruir de forma simples a vm e \u00e9 isso que faremos agora. vagrant destroy Com isso podemos ter nosso ambiente limpo outra vez: Configurando mais de uma m\u00e1quina virtual Agora que entendemos a din\u00e2mica de cria\u00e7\u00e3o de vms do vagrant, podemos configurar duas m\u00e1quinas para o ansible. Uma que vamos chamar de main que ser\u00e1 de onde chamaremos o ansible e uma que ser\u00e1 controlada por ele. Que se chamar\u00e1 somente arch . Para isso, s\u00f3 precisamos alterar nosso Vagrantfile : Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end end Agora temos duas m\u00e1quinas virtuais. Uma configurada com Archlinux e uma com Ubuntu Linux. Por\u00e9m cada uma tem uma fun\u00e7\u00e3o diferente na nossa rede. O vagrant pode subir uma \u00fanica vm ou as duas de uma vez: vagrant up # Inicia as duas vms vagrant up ubuntu # Somente a m\u00e1quina ubuntu vagrant up main # Somente a m\u00e1quina main (vamos escolher essa op\u00e7\u00e3o)","title":"B\u00e1sico necess\u00e1rio sobre Vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/#basico-necessario-sobre-vagrant","text":"Vagrant \u00e9 uma ferramenta para provisionamento de m\u00e1quinas virtuais. Dizendo de forma simples, ele cria e configura m\u00e1quinas virtuais usando um arquivo de configura\u00e7\u00e3o chamado Vagrantfile . Nesse arquivo podemos descrever como nossas vms ser\u00e3o configuradas. Exemplo de um arquivo do Vagrant: Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end A linha destacada \u00e9 referente a um box do Vagrant.","title":"B\u00e1sico necess\u00e1rio sobre Vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/#vagrant-boxes","text":"Um box do vagrant no nosso contexto \u00e9 uma m\u00e1quina virtual pr\u00e9-fabricada por uma pessoa. Existem milhares delas e elas podem ser acessadas no Vagrant Cloud Eu optei por usar m\u00e1quina do arch linux para iniciarmos nossa configura\u00e7\u00e3o.","title":"Vagrant boxes"},{"location":"02_o_basico_necessario_sobre_vagrant/#criando-uma-maquina-virtual","text":"Nosso primeiro passado \u00e9 copiar o seguinte Vagrantfile : Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end e colocar no diret\u00f3rio do nosso projeto. Que vamos inicialmente chamar de ansible-lab . Dessa forma podemos criar nossa m\u00e1quina virtual usando um simples comando: $ Execu\u00e7\u00e3o no terminal vagrant up O resultado deve ser algo parecido com isso: Bringing machine 'default' up with 'virtualbox' provider... == > default: Importing base box 'archlinux/archlinux' ... == > default: Matching MAC address for NAT networking... == > default: Checking if box 'archlinux/archlinux' version '20221101.99038' is up to date... == > default: Setting the name of the VM: ansible_lab_default_1668393945684_70462 == > default: Clearing any previously set network interfaces... == > default: Preparing network interfaces based on configuration... default: Adapter 1 : nat == > default: Forwarding ports... default: 22 ( guest ) = > 2222 ( host ) ( adapter 1 ) == > default: Booting VM... == > default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127 .0.0.1:2222 default: SSH username: vagrant default: SSH auth method: private key default: Warning: Connection reset. Retrying... default: Warning: Remote connection disconnect. Retrying... default: default: Vagrant insecure key detected. Vagrant will automatically replace default: this with a newly generated keypair for better security. default: default: Inserting generated public key within guest... default: Removing insecure key from the guest if it ' s present... default: Key inserted! Disconnecting and reconnecting using new SSH key... == > default: Machine booted and ready! == > default: Checking for guest additions in VM... == > default: Mounting shared folders... default: /vagrant = > /home/z4r4tu5tr4/ansible_lab E ele criar\u00e1 uma m\u00e1quina virtual com archlinux no nosso virtualbox. OBS: Esse comando pode demorar um pouco pois ele vai baixar um hd virtual do archlinux e instalar no seu virtualbox. Agora que temos uma m\u00e1quina virtual podemos partir para o segundo passo. Que \u00e9 criar dois n\u00f3s para trabalhar com ansible.","title":"Criando uma m\u00e1quina virtual"},{"location":"02_o_basico_necessario_sobre_vagrant/#destruindo-a-maquina-criada","text":"Caso voc\u00ea tenha problemas ou queira simplesmente destruir a m\u00e1quina virutal. O vagrant pode destruir de forma simples a vm e \u00e9 isso que faremos agora. vagrant destroy Com isso podemos ter nosso ambiente limpo outra vez:","title":"Destruindo a m\u00e1quina criada"},{"location":"02_o_basico_necessario_sobre_vagrant/#configurando-mais-de-uma-maquina-virtual","text":"Agora que entendemos a din\u00e2mica de cria\u00e7\u00e3o de vms do vagrant, podemos configurar duas m\u00e1quinas para o ansible. Uma que vamos chamar de main que ser\u00e1 de onde chamaremos o ansible e uma que ser\u00e1 controlada por ele. Que se chamar\u00e1 somente arch . Para isso, s\u00f3 precisamos alterar nosso Vagrantfile : Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end end Agora temos duas m\u00e1quinas virtuais. Uma configurada com Archlinux e uma com Ubuntu Linux. Por\u00e9m cada uma tem uma fun\u00e7\u00e3o diferente na nossa rede. O vagrant pode subir uma \u00fanica vm ou as duas de uma vez: vagrant up # Inicia as duas vms vagrant up ubuntu # Somente a m\u00e1quina ubuntu vagrant up main # Somente a m\u00e1quina main (vamos escolher essa op\u00e7\u00e3o)","title":"Configurando mais de uma m\u00e1quina virtual"},{"location":"03_ansible_basico/","text":"Ansible b\u00e1sico Ansible \u00e9 um grupo de ferramentas de c\u00f3digo aberto constru\u00eddas em python. O objetivo do Ansible \u00e9 automatizar tarefas de diversas naturezas. Foi originalmente escrito por Michael DeHaan em 2012 e foi comprado pela Red Hat em 2015. curiosidade A palavra Ansible foi cunhada por Ursula K. Le Guin no livro O mundo de Rocannon No livro existem diversos mundos e viajantes navegam na velocidade da luz. Ansible \u00e9 um dispositivo que de comunica\u00e7\u00e3o de comunica\u00e7\u00e3o instant\u00e2nea pelo universo. Automa\u00e7\u00f5es Quando falamos sobre Ansible, estamos falando sobre qualquer tipo de automa\u00e7\u00e3o em m\u00e1quinas. Alguns exemplos comuns s\u00e3o: Provisionamento de ambientes Gerenciamento de configura\u00e7\u00e3o Implanta\u00e7\u00e3o de aplicativos Entre outras coisas que podemos fazer com o ferramental Provisionamento Provisionamento \u00e9 o processo de preparar um dispositivo para que ele possa entrar em produ\u00e7\u00e3o. N\u00e3o s\u00f3 exatamente a respeito do hardware, mas a prepara\u00e7\u00e3o do sistema operacional a escolha dos aplicativos instalados e etc... Vimos nesse pequeno tutorial outra ferramenta de provisionamento, o Vagrant, que consegue montar a m\u00e1quina virtual, fornecer a instala\u00e7\u00e3o do sistema operacional. A parte que envolve o ansible \u00e9 mais referente a configura\u00e7\u00e3o dos pacotes instalados, a instala\u00e7\u00e3o dos softwares necess\u00e1rios para colocar uma m\u00e1quina, geralmente um servidor, em funcionamento. Gerenciamento de configura\u00e7\u00e3o O gerenciamento de configura\u00e7\u00e3o \u00e9 uma das partes do provisionamento, por\u00e9m com foco e configurar as aplica\u00e7\u00f5es instaladas no sistema operacional para que ele se comporte como esperado em produ\u00e7\u00e3o. Implanta\u00e7\u00e3o de aplicativos Ap\u00f3s toda a fase de instala\u00e7\u00e3o e configura\u00e7\u00e3o do ambiente e do sistema operacional, podemos colocar nossos aplicativos para serem executados nessas m\u00e1quinas. Um exemplo Vamos pensar que fizemos uma aplica\u00e7\u00e3o web com Python. Para que essa aplica\u00e7\u00e3o seja usada em um servidor o servidor tem que atender diversos requisitos para executar a nossa aplica\u00e7\u00e3o. Independentemente da op\u00e7\u00e3o que voc\u00ea escolha para fazer o deploy dela. De forma simples, temos que instalar o python na vers\u00e3o correta, fazer a instala\u00e7\u00e3o das bibliotecas necess\u00e1rias, configurar um banco de dados. Fazer com que a aplica\u00e7\u00e3o e o banco de dados conversem. Para que isso ocorra na nuvem, por exemplo, algu\u00e9m deve ter provisionado um sistema base, como um ubuntu linux , geralmente usando algum sistema de virtualiza\u00e7\u00e3o. Como fizemos aqui com VirtualBox, por\u00e9m em uma escala muito maior. Essa m\u00e1quina tem que ter ao menos um servi\u00e7o de SSH configurado para que possamos acessar esse computador do conforto da nossa casa. \u00c9 nesse contexto que o Ansible entra. Pegamos um sistema operacional limpo e iniciamos as nossas configura\u00e7\u00f5es e instala\u00e7\u00f5es para que nossa aplica\u00e7\u00e3o possa ser executada nesse servidor. Instala\u00e7\u00e3o do ansible Agora que temos duas m\u00e1quinas virtuais criadas. Podemos come\u00e7ar a instala\u00e7\u00e3o do ansible. A primeira coisa que devemos fazer \u00e9 acessar a m\u00e1quina controladora. Para isso podemos usar o vagrant para nos ajudar: vagrant up main # Iniciar a m\u00e1quina controladora vagrant ssh main # Acessar o console da m\u00e1quina controladora via ssh E isso deve retornar o console d\u00e1 maquina controladora no usu\u00e1rio vagrant : O ansible tem seus pacotes nos reposit\u00f3rios de quase todas as distribui\u00e7\u00f5es linux. Ent\u00e3o voc\u00ea pode instalar no seu sistema como quiser. Caso tenha d\u00favidas, o link da documenta\u00e7\u00e3o Formas de instalar em diversos sistemas. sudo pacman -S ansible # Arch sudo apt install ansible # Ubuntu sudo dnf ansible # Familia Redhat O ansible tamb\u00e9m pode ser instalado via pip , por\u00e9m a instala\u00e7\u00e3o \u00e9 bastante trabalhosa. Como eu escolhi que a m\u00e1quina main fosse um archlinux, vamos seguir a configura\u00e7\u00e3o com ele. O primeiro passo que devemos fazer \u00e9 atualizar a m\u00e1quina para garantir que tudo funcione como o esperado: sudo pacman -Syu # Atualiza o sistema Caso a senha senha perguntada. A senha padr\u00e3o criada pelas m\u00e1quinas virtuais do vagrant \u00e9 vagrant . Agora podemos rodar o comando para instalar o ansible: sudo pacman -S ansible Se tudo ocorrer como o esperado, podemos perguntar a vers\u00e3o do ansible ao sistema: [ vagrant@archlinux ~ ] $ ansible --version ansible [ core 2 .14.0 ] config file = /etc/ansible/ansible.cfg configured module search path = [ '/home/vagrant/.ansible/plugins/modules' , '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/lib/python3.10/site-packages/ansible ansible collection location = /home/vagrant/.ansible/collections:/usr/share/ansible/collections executable location = /usr/bin/ansible python version = 3 .10.8 ( main, Nov 1 2022 , 14 :18:21 ) [ GCC 12 .2.0 ] ( /usr/bin/python ) jinja version = 3 .1.2 libyaml = True Ele nos disse que est\u00e1 na vers\u00e3o 3.10.8 Um pouco de ansible na pr\u00e1tica O ansible foi pensado para que pud\u00e9ssemos automatizar uma tarefa de qualquer natureza. Para isso basta ter o ansible instalado na sua m\u00e1quina e cham\u00e1-lo via linha de comando. Instala\u00e7\u00e3o de um pacote Por exemplo, vamos supor que no nosso ambiente \u00e9 imprescind\u00edvel que o editor de texto GNU/Emacs esteja instalado (para mim costuma ser). Ent\u00e3o podemos usar o ansible para instalar o Emacs no nosso computador pessoal: $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=emacs state=present\" -b Com esse simples comando, temos o GNU/Emacs instalado nesse computador. Mas, o que realmente aconteceu aqui? Fragmento do comando O que faz? ansible Invoca o ansible localhost Diz qual m\u00e1quina ser\u00e1 afetada pelo comando -m Diz que vamos chamar um m\u00f3dulo package package \u00e9 o nome do m\u00f3dulo que vamos chamar -a Indica que vamos passar argumentos para o m\u00f3dulo \"name=emacs state=present\" Argumentos do m\u00f3dulo -b Diz ao Ansible que o comando ser\u00e1 executado como root O m\u00f3dulo package \u00e9 um dos muitos m\u00f3dulos ofertados pelo Ansible. Voc\u00ea pode ver uma lista completa aqui nesse link . O que dissemos por\u00e9m \u00e9: \"Modulo package garanta que o pacote emacs esteja presente no sistema em que for executado\". Podemos checar no terminal: $ Execu\u00e7\u00e3o no terminal emacs Caso tenha ficado preso Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs Configura\u00e7\u00e3o do pacote Embora o GNU/Emacs esteja instalado no meu sistema. Ele ainda n\u00e3o foi configurado da maneira que eu gostaria. N\u00e3o tem as minhas cores, os meus atalhos e para isso precisamos baixar meu arquivo de configura\u00e7\u00e3o que est\u00e1 no github.com/dunossauro/dotfiles . Para isso, podemos contar com outro m\u00f3dulo dispon\u00edvel no Ansible, o git . Ent\u00e3o, vamos baixar as minhas configura\u00e7\u00f5es: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" E com isso, obtivemos um erro: Resposta do terminal localhost | FAILED! = > { \"changed\" : false, \"msg\" : \"Failed to find required executable \\\"git\\\" in paths: /usr/local/sbin:/usr/local/bin:/usr/bin:/sbin:/usr/sbin\" } O ansible n\u00e3o conseguiu achar o git no nosso sistema, ele precisa ser instalado. Como j\u00e1 conhecemos o m\u00f3dulo package, ser\u00e1 f\u00e1cil. S\u00f3 dizer ao m\u00f3dulo package que git deve estar present : $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=git state=present\" -b Ap\u00f3s instalar o git, podemos testar nosso m\u00f3dulo de git outra vez: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" Resposta do terminal localhost | CHANGED = > { \"after\" : \"8ff42a43ede85403b6b85c0bab9a1a4fe0d73544\" , \"before\" : null, \"changed\" : true } CHANGED , significa que uma a\u00e7\u00e3o foi executada e agora temos os arquivos no nosso computador na pasta dest que passamos como argumento. $ Execu\u00e7\u00e3o no terminal ls config_files/.emacs.d init.el Agora s\u00f3 falta colocar a nossa configura\u00e7\u00e3o no lugar certo. O diret\u00f3rio ~/.emacs.d/ . Para isso podemos contar com outro m\u00f3dulo do copy : $ Execu\u00e7\u00e3o no terminal ansible localhost -m copy -a \"dest='/home/vagrant/' src='/home/vagrant/config_files/.emacs.d'\" Ap\u00f3s isso, podemos abrir o emacs novamente: $ Execu\u00e7\u00e3o no terminal emacs Pode demorar um pouco para as configura\u00e7\u00f5es serem baixadas e instaladas da internet. E temos o emacs com as minhas configura\u00e7\u00f5es: Caso tenha ficado preso OUTRA VEZ Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Ansible b\u00e1sico"},{"location":"03_ansible_basico/#ansible-basico","text":"Ansible \u00e9 um grupo de ferramentas de c\u00f3digo aberto constru\u00eddas em python. O objetivo do Ansible \u00e9 automatizar tarefas de diversas naturezas. Foi originalmente escrito por Michael DeHaan em 2012 e foi comprado pela Red Hat em 2015. curiosidade A palavra Ansible foi cunhada por Ursula K. Le Guin no livro O mundo de Rocannon No livro existem diversos mundos e viajantes navegam na velocidade da luz. Ansible \u00e9 um dispositivo que de comunica\u00e7\u00e3o de comunica\u00e7\u00e3o instant\u00e2nea pelo universo.","title":"Ansible b\u00e1sico"},{"location":"03_ansible_basico/#automacoes","text":"Quando falamos sobre Ansible, estamos falando sobre qualquer tipo de automa\u00e7\u00e3o em m\u00e1quinas. Alguns exemplos comuns s\u00e3o: Provisionamento de ambientes Gerenciamento de configura\u00e7\u00e3o Implanta\u00e7\u00e3o de aplicativos Entre outras coisas que podemos fazer com o ferramental","title":"Automa\u00e7\u00f5es"},{"location":"03_ansible_basico/#provisionamento","text":"Provisionamento \u00e9 o processo de preparar um dispositivo para que ele possa entrar em produ\u00e7\u00e3o. N\u00e3o s\u00f3 exatamente a respeito do hardware, mas a prepara\u00e7\u00e3o do sistema operacional a escolha dos aplicativos instalados e etc... Vimos nesse pequeno tutorial outra ferramenta de provisionamento, o Vagrant, que consegue montar a m\u00e1quina virtual, fornecer a instala\u00e7\u00e3o do sistema operacional. A parte que envolve o ansible \u00e9 mais referente a configura\u00e7\u00e3o dos pacotes instalados, a instala\u00e7\u00e3o dos softwares necess\u00e1rios para colocar uma m\u00e1quina, geralmente um servidor, em funcionamento.","title":"Provisionamento"},{"location":"03_ansible_basico/#gerenciamento-de-configuracao","text":"O gerenciamento de configura\u00e7\u00e3o \u00e9 uma das partes do provisionamento, por\u00e9m com foco e configurar as aplica\u00e7\u00f5es instaladas no sistema operacional para que ele se comporte como esperado em produ\u00e7\u00e3o.","title":"Gerenciamento de configura\u00e7\u00e3o"},{"location":"03_ansible_basico/#implantacao-de-aplicativos","text":"Ap\u00f3s toda a fase de instala\u00e7\u00e3o e configura\u00e7\u00e3o do ambiente e do sistema operacional, podemos colocar nossos aplicativos para serem executados nessas m\u00e1quinas.","title":"Implanta\u00e7\u00e3o de aplicativos"},{"location":"03_ansible_basico/#um-exemplo","text":"Vamos pensar que fizemos uma aplica\u00e7\u00e3o web com Python. Para que essa aplica\u00e7\u00e3o seja usada em um servidor o servidor tem que atender diversos requisitos para executar a nossa aplica\u00e7\u00e3o. Independentemente da op\u00e7\u00e3o que voc\u00ea escolha para fazer o deploy dela. De forma simples, temos que instalar o python na vers\u00e3o correta, fazer a instala\u00e7\u00e3o das bibliotecas necess\u00e1rias, configurar um banco de dados. Fazer com que a aplica\u00e7\u00e3o e o banco de dados conversem. Para que isso ocorra na nuvem, por exemplo, algu\u00e9m deve ter provisionado um sistema base, como um ubuntu linux , geralmente usando algum sistema de virtualiza\u00e7\u00e3o. Como fizemos aqui com VirtualBox, por\u00e9m em uma escala muito maior. Essa m\u00e1quina tem que ter ao menos um servi\u00e7o de SSH configurado para que possamos acessar esse computador do conforto da nossa casa. \u00c9 nesse contexto que o Ansible entra. Pegamos um sistema operacional limpo e iniciamos as nossas configura\u00e7\u00f5es e instala\u00e7\u00f5es para que nossa aplica\u00e7\u00e3o possa ser executada nesse servidor.","title":"Um exemplo"},{"location":"03_ansible_basico/#instalacao-do-ansible","text":"Agora que temos duas m\u00e1quinas virtuais criadas. Podemos come\u00e7ar a instala\u00e7\u00e3o do ansible. A primeira coisa que devemos fazer \u00e9 acessar a m\u00e1quina controladora. Para isso podemos usar o vagrant para nos ajudar: vagrant up main # Iniciar a m\u00e1quina controladora vagrant ssh main # Acessar o console da m\u00e1quina controladora via ssh E isso deve retornar o console d\u00e1 maquina controladora no usu\u00e1rio vagrant : O ansible tem seus pacotes nos reposit\u00f3rios de quase todas as distribui\u00e7\u00f5es linux. Ent\u00e3o voc\u00ea pode instalar no seu sistema como quiser. Caso tenha d\u00favidas, o link da documenta\u00e7\u00e3o Formas de instalar em diversos sistemas. sudo pacman -S ansible # Arch sudo apt install ansible # Ubuntu sudo dnf ansible # Familia Redhat O ansible tamb\u00e9m pode ser instalado via pip , por\u00e9m a instala\u00e7\u00e3o \u00e9 bastante trabalhosa. Como eu escolhi que a m\u00e1quina main fosse um archlinux, vamos seguir a configura\u00e7\u00e3o com ele. O primeiro passo que devemos fazer \u00e9 atualizar a m\u00e1quina para garantir que tudo funcione como o esperado: sudo pacman -Syu # Atualiza o sistema Caso a senha senha perguntada. A senha padr\u00e3o criada pelas m\u00e1quinas virtuais do vagrant \u00e9 vagrant . Agora podemos rodar o comando para instalar o ansible: sudo pacman -S ansible Se tudo ocorrer como o esperado, podemos perguntar a vers\u00e3o do ansible ao sistema: [ vagrant@archlinux ~ ] $ ansible --version ansible [ core 2 .14.0 ] config file = /etc/ansible/ansible.cfg configured module search path = [ '/home/vagrant/.ansible/plugins/modules' , '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/lib/python3.10/site-packages/ansible ansible collection location = /home/vagrant/.ansible/collections:/usr/share/ansible/collections executable location = /usr/bin/ansible python version = 3 .10.8 ( main, Nov 1 2022 , 14 :18:21 ) [ GCC 12 .2.0 ] ( /usr/bin/python ) jinja version = 3 .1.2 libyaml = True Ele nos disse que est\u00e1 na vers\u00e3o 3.10.8","title":"Instala\u00e7\u00e3o do ansible"},{"location":"03_ansible_basico/#um-pouco-de-ansible-na-pratica","text":"O ansible foi pensado para que pud\u00e9ssemos automatizar uma tarefa de qualquer natureza. Para isso basta ter o ansible instalado na sua m\u00e1quina e cham\u00e1-lo via linha de comando.","title":"Um pouco de ansible na pr\u00e1tica"},{"location":"03_ansible_basico/#instalacao-de-um-pacote","text":"Por exemplo, vamos supor que no nosso ambiente \u00e9 imprescind\u00edvel que o editor de texto GNU/Emacs esteja instalado (para mim costuma ser). Ent\u00e3o podemos usar o ansible para instalar o Emacs no nosso computador pessoal: $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=emacs state=present\" -b Com esse simples comando, temos o GNU/Emacs instalado nesse computador. Mas, o que realmente aconteceu aqui? Fragmento do comando O que faz? ansible Invoca o ansible localhost Diz qual m\u00e1quina ser\u00e1 afetada pelo comando -m Diz que vamos chamar um m\u00f3dulo package package \u00e9 o nome do m\u00f3dulo que vamos chamar -a Indica que vamos passar argumentos para o m\u00f3dulo \"name=emacs state=present\" Argumentos do m\u00f3dulo -b Diz ao Ansible que o comando ser\u00e1 executado como root O m\u00f3dulo package \u00e9 um dos muitos m\u00f3dulos ofertados pelo Ansible. Voc\u00ea pode ver uma lista completa aqui nesse link . O que dissemos por\u00e9m \u00e9: \"Modulo package garanta que o pacote emacs esteja presente no sistema em que for executado\". Podemos checar no terminal: $ Execu\u00e7\u00e3o no terminal emacs Caso tenha ficado preso Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Instala\u00e7\u00e3o de um pacote"},{"location":"03_ansible_basico/#configuracao-do-pacote","text":"Embora o GNU/Emacs esteja instalado no meu sistema. Ele ainda n\u00e3o foi configurado da maneira que eu gostaria. N\u00e3o tem as minhas cores, os meus atalhos e para isso precisamos baixar meu arquivo de configura\u00e7\u00e3o que est\u00e1 no github.com/dunossauro/dotfiles . Para isso, podemos contar com outro m\u00f3dulo dispon\u00edvel no Ansible, o git . Ent\u00e3o, vamos baixar as minhas configura\u00e7\u00f5es: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" E com isso, obtivemos um erro: Resposta do terminal localhost | FAILED! = > { \"changed\" : false, \"msg\" : \"Failed to find required executable \\\"git\\\" in paths: /usr/local/sbin:/usr/local/bin:/usr/bin:/sbin:/usr/sbin\" } O ansible n\u00e3o conseguiu achar o git no nosso sistema, ele precisa ser instalado. Como j\u00e1 conhecemos o m\u00f3dulo package, ser\u00e1 f\u00e1cil. S\u00f3 dizer ao m\u00f3dulo package que git deve estar present : $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=git state=present\" -b Ap\u00f3s instalar o git, podemos testar nosso m\u00f3dulo de git outra vez: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" Resposta do terminal localhost | CHANGED = > { \"after\" : \"8ff42a43ede85403b6b85c0bab9a1a4fe0d73544\" , \"before\" : null, \"changed\" : true } CHANGED , significa que uma a\u00e7\u00e3o foi executada e agora temos os arquivos no nosso computador na pasta dest que passamos como argumento. $ Execu\u00e7\u00e3o no terminal ls config_files/.emacs.d init.el Agora s\u00f3 falta colocar a nossa configura\u00e7\u00e3o no lugar certo. O diret\u00f3rio ~/.emacs.d/ . Para isso podemos contar com outro m\u00f3dulo do copy : $ Execu\u00e7\u00e3o no terminal ansible localhost -m copy -a \"dest='/home/vagrant/' src='/home/vagrant/config_files/.emacs.d'\" Ap\u00f3s isso, podemos abrir o emacs novamente: $ Execu\u00e7\u00e3o no terminal emacs Pode demorar um pouco para as configura\u00e7\u00f5es serem baixadas e instaladas da internet. E temos o emacs com as minhas configura\u00e7\u00f5es: Caso tenha ficado preso OUTRA VEZ Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Configura\u00e7\u00e3o do pacote"},{"location":"04_configuracao_do_ansible/","text":"Entendendo a estrutura do ansible Embora at\u00e9 o momento executamos o ansible somente em uma m\u00e1quina local. E confesso que j\u00e1 pode ser bastante \u00fatil para padronizar suas configura\u00e7\u00f5es ap\u00f3s uma formata\u00e7\u00e3o, por exemplo. O Ansible brilha quando estamos falando de rede. Arquitetura de uso do ansible O Ansible distingue as m\u00e1quinas em duas categorias. O n\u00f3 de controle, onde o ansible est\u00e1 instalado e os n\u00f3s controlados. Que m\u00e1quinas em que o ansible pode se comunicar via SSH e executar os comandos: Dessa forma podemos partir do n\u00f3 de Controle e enviar rotinas de automa\u00e7\u00e3o para todos os n\u00f3s Controlados . Para isso o ansible conta com um arquivo de invent\u00e1rio. Um lugar onde todas as m\u00e1quinas que ser\u00e3o controladas pelo controlador devem ser registradas. Arquivo de invent\u00e1rio Por padr\u00e3o o arquivo de invent\u00e1rio das m\u00e1quinas ficam no /etc/ansible/hosts . Vamos criar esse arquivo agora. $ Execu\u00e7\u00e3o no terminal # instala\u00e7\u00e3o do Nano, n\u00e3o vou obrigar ningu\u00e9m a usar o Emacs ;) ansible localhost -m package -a \"name=emacs state=present\" -b sudo nano /etc/ansible/hosts \u00c9 nesse arquivo que colocamos os endere\u00e7os dos n\u00f3s que ser\u00e3o controlados pelo ansible. O arquivo tem o seguinte formato: [<nome_do_grupo>] <endere\u00e7o_da_maquina> <op\u00e7\u00f5es> Por exemplo, vamos cadastrar nossa outra vm arch que ser\u00e1 controlado pelo main . Para isso, precisamos iniciar essa m\u00e1quina virtual. Antes disso, temos que sair do ssh em main : $ Execu\u00e7\u00e3o no terminal exit Agora voltamos a maquina principal. A m\u00e1quina onde as m\u00e1quinas virtuais foram instaladas. Vamos iniciar nossa outra m\u00e1quina. O ubuntu : vagrant up ubuntu Com isso, agora devemos ter duas m\u00e1quinas no nosso virtual box: [AA] - Mudar essa imagem Com nossa vm j\u00e1 de p\u00e9, podemos enviar um comando para o vagrant nos dizer o endere\u00e7o ip da m\u00e1quina ubuntu : $ Execu\u00e7\u00e3o no terminal vagrant ssh ubuntu -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.15 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Podemos ver que o IP associado a ubuntu \u00e9 10.0.2.15 . Que \u00e9 o endere\u00e7o que colocaremos no nosso invent\u00e1rio. Agora vamos voltar a nossa m\u00e1quina main via ssh: $ Execu\u00e7\u00e3o no terminal vagrant ssh main E vamos alterar nosso arquivo /etc/ansible/hosts dessa forma e com o comando sudo nano /etc/ansible/hosts : /etc/ansible/hosts 1 2 [ubuntu] 10.0.2.15 Dessa forma dissemos ao ansible que existe um grupo chamado ubuntu , uma dessas m\u00e1quinas tem o ip 10.0.2.15 . Assim, podemos enviar comandos para o grupo ubuntu . Primeiro comando remoto E podemos checar enviando um ping para a vm ubuntu usando o seguinte comando ansible ubuntu -m ping : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m ping The authenticity of host '10.0.2.15 (10.0.2.15)' can 't be established. ED25519 key fingerprint is SHA256:FyOy2yTlOHSLJXVF+lmYjPywdfmQprApMWrsQ7KxUlI. This host key is known by the following other names/addresses: ~/.ssh/known_hosts:1: localhost Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 10.0.2.15 | UNREACHABLE! => { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: Warning: Permanently added ' 10 .0.2.15 ' ( ED25519 ) to the list of known hosts. \\r\\n vagrant@10.0.2.15: Permission denied ( publickey,password ) . \", \" unreachable \": true } Um erro ocorreu por conta da seguran\u00e7a. O SSH da vm ubuntu n\u00e3o permitiu que o ansible fizesse a conex\u00e3o. Para isso precisamos trocar chaves entre os hosts para que aconte\u00e7a de maneira segura. Troca de chaves SSH Vamos voltar ao shell e digitar os seguintes comandos: $ Execu\u00e7\u00e3o no terminal ssh-keygen # para gerar uma chave ssh para nossa vm `main` ssh-copy-id vagrant@10.0.2.15 # Para copiar a chave de `main` para `ubuntu` Se executarmos o ping novamente obteremos sucesso: $ Execu\u00e7\u00e3o no terminal ansible arch -m ping 10 .0.2.15 | SUCCESS = > { \"ansible_facts\" : { \"discovered_interpreter_python\" : \"/usr/bin/python3.10\" } , \"changed\" : false, \"ping\" : \"pong\" } Isso significa que a comunica\u00e7\u00e3o com os dois n\u00f3s est\u00e1 acontecendo de maneira correta. Mas, faltou entender o que o comando ansible ubuntu -m ping significa: ansible: Chama o ansible ubuntu: O nome do grupo do invent\u00e1rio -m: Significa que vamos chamar um m\u00f3dulo ping: M\u00f3dulo para checar se o grupo est\u00e1 respondendo Repetindo o processo para mais uma m\u00e1quina Agora que j\u00e1 entendemos o que temos que fazer. Podemos adicionar mais uma m\u00e1quina virtual ao nosso ambiente. Vamos criar mais um arch para que seja controlado pelo ansible: Vagrantfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end config . vm . define \"arch\" do | arch | main . vm . box = \"archlinux/archlinux\" end end Agora podemos dar up nessa nova m\u00e1quina: $ Execu\u00e7\u00e3o no terminal exit # caso esteja no conectado no main vagrant up arch Pegamos o endere\u00e7o de ip: $ Execu\u00e7\u00e3o no terminal vagrant ssh arch -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.16 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Adicionamos esse ip no invent\u00e1rio da m\u00e1quina controladora: /etc/ansible/hosts 1 2 3 4 5 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 Fazemos a troca de chaves SSH, para que o Controlador se comunique de forma segura com o arch : $ Execu\u00e7\u00e3o no terminal ssh-copy-id vagrant@10.0.2.16 # Para copiar a chave de `main` para `arch` Com isso temos dois grupos no n\u00f3 de controle. O ubuntu e o arch . Podemos criar um grupo novo tamb\u00e9m para juntar todos os linux e disparar comandos que funcionem nas duas m\u00e1quinas ao mesmo tempo: /etc/ansible/hosts 1 2 3 4 5 6 7 8 9 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 [linux] 10.0.2.15 10.0.2.16 Dessa forma, podemos chamar o m\u00f3dulo ping para todos os n\u00f3s em um grupo s\u00f3: $ Execu\u00e7\u00e3o no terminal ansible linux -m ping Caso tudo esteja configurado corretamente. Iremos obter sucesso em ambos os pings. O que significa que o comando foi executado com sucesso nas duas m\u00e1quinas. Instalando um pacote em dois n\u00f3s ao mesmo tempo Vamos iniciar uma configura\u00e7\u00e3o simples e que j\u00e1 rodamos no n\u00f3 controlador. Meu objetivo, por\u00e9m, \u00e9 mostrar a voc\u00eas o poder do ansible de forma simples: $ Execu\u00e7\u00e3o no terminal ansible linux -m package -a \"name=nginx state=present\" -b Dessa forma acabamos de instalar o servidor web Nginx nas nossas duas m\u00e1quinas virtuais ao mesmo tempo. Uma coisa importante de notar e que diferencia de uma forma simpl\u00f3ria de instala\u00e7\u00e3o. \u00c9 que n\u00e3o foi preciso dizer nem ao menos qual o gerenciador de pacotes que \u00e9 usado em cada distribui\u00e7\u00e3o. O m\u00f3dulo package entende isso por padr\u00e3o e usa o gerenciador da distribui\u00e7\u00e3o por baixo dos panos. Com isso, podemos conhecer outro m\u00f3dulo. O m\u00f3dulo do systemd e com ele podemos dizer que queremos dar start no processo do Nginx: $ Execu\u00e7\u00e3o no terminal ansible linux -m systemd -a \"name=nginx state=started\" -b E vol\u00e1, instalamos o Nginx em duas m\u00e1quinas e subimos o server somente usando comandos simples e sem a preocupa\u00e7\u00e3o de ter de entender coisas espec\u00edficas de sistema. Vamos ver se o servi\u00e7o subiu da forma correta? Para isso vou me aproveitar do ansible para instalar o httpie no sistema para fazer essa requisi\u00e7\u00e3o no n\u00f3 controlador. Por\u00e9m n\u00e3o quero fazer essa instala\u00e7\u00e3o sujando o ambiente. Ent\u00e3o, vamos instalar o pipx $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=python-pipx state=present\" -b Agora com o pipx instalado, podemos usar ele via m\u00f3dulo shell para instalar o httpie: $ Execu\u00e7\u00e3o no terminal ansible localhost -m shell -a \"pipx install httpie\" E agora, finalmente, podemos checar se ambos os servi\u00e7os foram startados corretamente pelo ansible: $ Execu\u00e7\u00e3o no terminal http 10 .0.2.15 http 10 .0.2.16 Embora tudo tenha sido executado de forma incr\u00edvel. Ainda considero chato de mais ficar chamando o ansible no terminal o tempo todo. Ent\u00e3o, precisamos de uma forma de melhorar isso.","title":"Entendendo a estrutura do ansible"},{"location":"04_configuracao_do_ansible/#entendendo-a-estrutura-do-ansible","text":"Embora at\u00e9 o momento executamos o ansible somente em uma m\u00e1quina local. E confesso que j\u00e1 pode ser bastante \u00fatil para padronizar suas configura\u00e7\u00f5es ap\u00f3s uma formata\u00e7\u00e3o, por exemplo. O Ansible brilha quando estamos falando de rede.","title":"Entendendo a estrutura do ansible"},{"location":"04_configuracao_do_ansible/#arquitetura-de-uso-do-ansible","text":"O Ansible distingue as m\u00e1quinas em duas categorias. O n\u00f3 de controle, onde o ansible est\u00e1 instalado e os n\u00f3s controlados. Que m\u00e1quinas em que o ansible pode se comunicar via SSH e executar os comandos: Dessa forma podemos partir do n\u00f3 de Controle e enviar rotinas de automa\u00e7\u00e3o para todos os n\u00f3s Controlados . Para isso o ansible conta com um arquivo de invent\u00e1rio. Um lugar onde todas as m\u00e1quinas que ser\u00e3o controladas pelo controlador devem ser registradas.","title":"Arquitetura de uso do ansible"},{"location":"04_configuracao_do_ansible/#arquivo-de-inventario","text":"Por padr\u00e3o o arquivo de invent\u00e1rio das m\u00e1quinas ficam no /etc/ansible/hosts . Vamos criar esse arquivo agora. $ Execu\u00e7\u00e3o no terminal # instala\u00e7\u00e3o do Nano, n\u00e3o vou obrigar ningu\u00e9m a usar o Emacs ;) ansible localhost -m package -a \"name=emacs state=present\" -b sudo nano /etc/ansible/hosts \u00c9 nesse arquivo que colocamos os endere\u00e7os dos n\u00f3s que ser\u00e3o controlados pelo ansible. O arquivo tem o seguinte formato: [<nome_do_grupo>] <endere\u00e7o_da_maquina> <op\u00e7\u00f5es> Por exemplo, vamos cadastrar nossa outra vm arch que ser\u00e1 controlado pelo main . Para isso, precisamos iniciar essa m\u00e1quina virtual. Antes disso, temos que sair do ssh em main : $ Execu\u00e7\u00e3o no terminal exit Agora voltamos a maquina principal. A m\u00e1quina onde as m\u00e1quinas virtuais foram instaladas. Vamos iniciar nossa outra m\u00e1quina. O ubuntu : vagrant up ubuntu Com isso, agora devemos ter duas m\u00e1quinas no nosso virtual box: [AA] - Mudar essa imagem Com nossa vm j\u00e1 de p\u00e9, podemos enviar um comando para o vagrant nos dizer o endere\u00e7o ip da m\u00e1quina ubuntu : $ Execu\u00e7\u00e3o no terminal vagrant ssh ubuntu -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.15 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Podemos ver que o IP associado a ubuntu \u00e9 10.0.2.15 . Que \u00e9 o endere\u00e7o que colocaremos no nosso invent\u00e1rio. Agora vamos voltar a nossa m\u00e1quina main via ssh: $ Execu\u00e7\u00e3o no terminal vagrant ssh main E vamos alterar nosso arquivo /etc/ansible/hosts dessa forma e com o comando sudo nano /etc/ansible/hosts : /etc/ansible/hosts 1 2 [ubuntu] 10.0.2.15 Dessa forma dissemos ao ansible que existe um grupo chamado ubuntu , uma dessas m\u00e1quinas tem o ip 10.0.2.15 . Assim, podemos enviar comandos para o grupo ubuntu .","title":"Arquivo de invent\u00e1rio"},{"location":"04_configuracao_do_ansible/#primeiro-comando-remoto","text":"E podemos checar enviando um ping para a vm ubuntu usando o seguinte comando ansible ubuntu -m ping : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m ping The authenticity of host '10.0.2.15 (10.0.2.15)' can 't be established. ED25519 key fingerprint is SHA256:FyOy2yTlOHSLJXVF+lmYjPywdfmQprApMWrsQ7KxUlI. This host key is known by the following other names/addresses: ~/.ssh/known_hosts:1: localhost Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 10.0.2.15 | UNREACHABLE! => { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: Warning: Permanently added ' 10 .0.2.15 ' ( ED25519 ) to the list of known hosts. \\r\\n vagrant@10.0.2.15: Permission denied ( publickey,password ) . \", \" unreachable \": true } Um erro ocorreu por conta da seguran\u00e7a. O SSH da vm ubuntu n\u00e3o permitiu que o ansible fizesse a conex\u00e3o. Para isso precisamos trocar chaves entre os hosts para que aconte\u00e7a de maneira segura.","title":"Primeiro comando remoto"},{"location":"04_configuracao_do_ansible/#troca-de-chaves-ssh","text":"Vamos voltar ao shell e digitar os seguintes comandos: $ Execu\u00e7\u00e3o no terminal ssh-keygen # para gerar uma chave ssh para nossa vm `main` ssh-copy-id vagrant@10.0.2.15 # Para copiar a chave de `main` para `ubuntu` Se executarmos o ping novamente obteremos sucesso: $ Execu\u00e7\u00e3o no terminal ansible arch -m ping 10 .0.2.15 | SUCCESS = > { \"ansible_facts\" : { \"discovered_interpreter_python\" : \"/usr/bin/python3.10\" } , \"changed\" : false, \"ping\" : \"pong\" } Isso significa que a comunica\u00e7\u00e3o com os dois n\u00f3s est\u00e1 acontecendo de maneira correta. Mas, faltou entender o que o comando ansible ubuntu -m ping significa: ansible: Chama o ansible ubuntu: O nome do grupo do invent\u00e1rio -m: Significa que vamos chamar um m\u00f3dulo ping: M\u00f3dulo para checar se o grupo est\u00e1 respondendo","title":"Troca de chaves SSH"},{"location":"04_configuracao_do_ansible/#repetindo-o-processo-para-mais-uma-maquina","text":"Agora que j\u00e1 entendemos o que temos que fazer. Podemos adicionar mais uma m\u00e1quina virtual ao nosso ambiente. Vamos criar mais um arch para que seja controlado pelo ansible: Vagrantfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end config . vm . define \"arch\" do | arch | main . vm . box = \"archlinux/archlinux\" end end Agora podemos dar up nessa nova m\u00e1quina: $ Execu\u00e7\u00e3o no terminal exit # caso esteja no conectado no main vagrant up arch Pegamos o endere\u00e7o de ip: $ Execu\u00e7\u00e3o no terminal vagrant ssh arch -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.16 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Adicionamos esse ip no invent\u00e1rio da m\u00e1quina controladora: /etc/ansible/hosts 1 2 3 4 5 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 Fazemos a troca de chaves SSH, para que o Controlador se comunique de forma segura com o arch : $ Execu\u00e7\u00e3o no terminal ssh-copy-id vagrant@10.0.2.16 # Para copiar a chave de `main` para `arch` Com isso temos dois grupos no n\u00f3 de controle. O ubuntu e o arch . Podemos criar um grupo novo tamb\u00e9m para juntar todos os linux e disparar comandos que funcionem nas duas m\u00e1quinas ao mesmo tempo: /etc/ansible/hosts 1 2 3 4 5 6 7 8 9 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 [linux] 10.0.2.15 10.0.2.16 Dessa forma, podemos chamar o m\u00f3dulo ping para todos os n\u00f3s em um grupo s\u00f3: $ Execu\u00e7\u00e3o no terminal ansible linux -m ping Caso tudo esteja configurado corretamente. Iremos obter sucesso em ambos os pings. O que significa que o comando foi executado com sucesso nas duas m\u00e1quinas.","title":"Repetindo o processo para mais uma m\u00e1quina"},{"location":"04_configuracao_do_ansible/#instalando-um-pacote-em-dois-nos-ao-mesmo-tempo","text":"Vamos iniciar uma configura\u00e7\u00e3o simples e que j\u00e1 rodamos no n\u00f3 controlador. Meu objetivo, por\u00e9m, \u00e9 mostrar a voc\u00eas o poder do ansible de forma simples: $ Execu\u00e7\u00e3o no terminal ansible linux -m package -a \"name=nginx state=present\" -b Dessa forma acabamos de instalar o servidor web Nginx nas nossas duas m\u00e1quinas virtuais ao mesmo tempo. Uma coisa importante de notar e que diferencia de uma forma simpl\u00f3ria de instala\u00e7\u00e3o. \u00c9 que n\u00e3o foi preciso dizer nem ao menos qual o gerenciador de pacotes que \u00e9 usado em cada distribui\u00e7\u00e3o. O m\u00f3dulo package entende isso por padr\u00e3o e usa o gerenciador da distribui\u00e7\u00e3o por baixo dos panos. Com isso, podemos conhecer outro m\u00f3dulo. O m\u00f3dulo do systemd e com ele podemos dizer que queremos dar start no processo do Nginx: $ Execu\u00e7\u00e3o no terminal ansible linux -m systemd -a \"name=nginx state=started\" -b E vol\u00e1, instalamos o Nginx em duas m\u00e1quinas e subimos o server somente usando comandos simples e sem a preocupa\u00e7\u00e3o de ter de entender coisas espec\u00edficas de sistema. Vamos ver se o servi\u00e7o subiu da forma correta? Para isso vou me aproveitar do ansible para instalar o httpie no sistema para fazer essa requisi\u00e7\u00e3o no n\u00f3 controlador. Por\u00e9m n\u00e3o quero fazer essa instala\u00e7\u00e3o sujando o ambiente. Ent\u00e3o, vamos instalar o pipx $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=python-pipx state=present\" -b Agora com o pipx instalado, podemos usar ele via m\u00f3dulo shell para instalar o httpie: $ Execu\u00e7\u00e3o no terminal ansible localhost -m shell -a \"pipx install httpie\" E agora, finalmente, podemos checar se ambos os servi\u00e7os foram startados corretamente pelo ansible: $ Execu\u00e7\u00e3o no terminal http 10 .0.2.15 http 10 .0.2.16 Embora tudo tenha sido executado de forma incr\u00edvel. Ainda considero chato de mais ficar chamando o ansible no terminal o tempo todo. Ent\u00e3o, precisamos de uma forma de melhorar isso.","title":"Instalando um pacote em dois n\u00f3s ao mesmo tempo"},{"location":"05_playbooks/","text":"Playbooks Tudo que executamos at\u00e9 agora foram comandos no terminal com ansible. Voc\u00ea deve estar se perguntando se n\u00e3o seria mais f\u00e1cil criar um script com todos esses comandos, para evitar ter que digitar todas as vezes. Para isso existem os playbooks. Voc\u00ea cria um arquivo no formato yaml descrevendo todas as suas tarefas e executa de uma \u00fanica vez. O nome Playbook Playbook \u00e9 uma palavra que se refere a scripts de teatro. Por exemplo, quando algu\u00e9m entra em cena, as falas de cada personagem e etc... No mundo dos esportes playbook \u00e9 usado muito no baseball e no basket. S\u00e3o listas de jogadas que podem ser feitas durante um jogo. Arquivos YAML Arquivos YAML s\u00e3o arquivos geralmente usados para configura\u00e7\u00f5es. Se pensarmos em Python, eles formam estruturas equivalentes a de dicion\u00e1rios. Uma compara\u00e7\u00e3o b\u00e1sica para voc\u00ea entender o formato: YAML Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- chave : valor # valor \u00e9 uma string chave_int : 1 # valor \u00e9 uma int chave_bool : true # valor \u00e9 uma bool uma_lista : - item_0 - item_1 - item_2 um_dict : nome : eduardo idade : 29 # Coment\u00e1rios lista_inline : [ 'item_0' , 'item_1' , 'item_2' ] dict_inline : { 'nome' : 'eduardo' , 'idade' : 29 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"chave\" : \"valor\" , \"chave_int\" : 1 , \"chave_bool\" : true , \"uma_lista\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"um_dict\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 }, \"lista_inline\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"dict_inline\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 } } Nosso primeiro playbook Vamos reproduzir a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Ngix que fizemos via comandos ad-hoc no terminal: web_server.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- - name : Instala\u00e7\u00e3o do nginx hosts : linux # Grupo de hosts do invent\u00e1rio become : yes # Diz que vai escalonar privil\u00e9gios. Equivalente ao -b tasks : # Descri\u00e7\u00e3o das tarefas que ser\u00e3o executadas - name : Instala\u00e7\u00e3o do nginx # Nome da tarefa package : # Nome do m\u00f3dulo # Argumentos do m\u00f3dulo state : present name : nginx - name : Inicializa\u00e7\u00e3o do nginx systemd : state : started name : nginx Dessa forma, no lugar de executar um \u00fanico comando por vez, podemos disparar um playbook que executa diversas tarefas por vez: $ Execu\u00e7\u00e3o no terminal ansible-playbook web_server.yml Voc\u00ea deve ver uma grande resposta como essa: resposta do terminal ansible-playbook playbooks/web_server.yml PLAY [ Instala\u00e7\u00e3o do nginx ] ***************************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do nginx ] ***************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Inicializa\u00e7\u00e3o do nginx ] ************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ********************************************************************* 10 .0.2.15 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.16 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O que significa que o ansible conseguiu executar o playbook com sucesso. Mais um playbook Sei que voc\u00ea j\u00e1 deve ter captado a ideia do playbook, mas que tal criarmos mais um? Vamos tentar reproduzir a configura\u00e7\u00e3o do emacs no localhost agora. Pois temos outros m\u00f3dulos e outros comandos para aprender: emacs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- - name : Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs hosts : localhost # Aqui mudamos para o localhost tasks : - name : Instala\u00e7\u00e3o do emacs become : yes # Diferente da outra config, somente esse passo ser\u00e1 como root package : state : present name : emacs - name : Instala\u00e7\u00e3o do git become : yes package : name : git state : present - name : Clone do nosso reposit\u00f3rio git : repo : https://github.com/dunossauro/dotfiles.git dest : config_files - name : Movendo os arquivos de configura\u00e7\u00e3o do emacs copy : dest : /home/vagrant/ src : /home/vagrant/config_files/.emacs.d Se executarmos esse playbook podemos ver algumas mensagens diferentes na resposta: $ Execu\u00e7\u00e3o no terminal ansible-playbook emacs.yml A resposta: resposta do terminal PLAY [ Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs ] ************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do emacs ] ***************************************************** ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do git ] ******************************************************* ok: [ localhost ] TASK [ Clone do nosso reposit\u00f3rio ] ********************************************** changed : [ localhost ] TASK [ Movendo os arquivos de configura\u00e7\u00e3o do emacs ] **************************** changed : [ localhost ] PLAY RECAP ********************************************************************* localhost : ok = 5 changed = 2 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O status changed apareceu. Significa que o resultado desse comando foi diferente da primeira vez que foi executado. O que quer dizer que alguma coisa mudou desde a ultima execu\u00e7\u00e3o. Provavelmente a resposta do ansible foi diferente pois o clone n\u00e3o foi feito, o diret\u00f3rio j\u00e1 existia e o move tamb\u00e9m j\u00e1 tinha sido feito antes. Condicionais","title":"Playbooks"},{"location":"05_playbooks/#playbooks","text":"Tudo que executamos at\u00e9 agora foram comandos no terminal com ansible. Voc\u00ea deve estar se perguntando se n\u00e3o seria mais f\u00e1cil criar um script com todos esses comandos, para evitar ter que digitar todas as vezes. Para isso existem os playbooks. Voc\u00ea cria um arquivo no formato yaml descrevendo todas as suas tarefas e executa de uma \u00fanica vez. O nome Playbook Playbook \u00e9 uma palavra que se refere a scripts de teatro. Por exemplo, quando algu\u00e9m entra em cena, as falas de cada personagem e etc... No mundo dos esportes playbook \u00e9 usado muito no baseball e no basket. S\u00e3o listas de jogadas que podem ser feitas durante um jogo.","title":"Playbooks"},{"location":"05_playbooks/#arquivos-yaml","text":"Arquivos YAML s\u00e3o arquivos geralmente usados para configura\u00e7\u00f5es. Se pensarmos em Python, eles formam estruturas equivalentes a de dicion\u00e1rios. Uma compara\u00e7\u00e3o b\u00e1sica para voc\u00ea entender o formato: YAML Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- chave : valor # valor \u00e9 uma string chave_int : 1 # valor \u00e9 uma int chave_bool : true # valor \u00e9 uma bool uma_lista : - item_0 - item_1 - item_2 um_dict : nome : eduardo idade : 29 # Coment\u00e1rios lista_inline : [ 'item_0' , 'item_1' , 'item_2' ] dict_inline : { 'nome' : 'eduardo' , 'idade' : 29 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"chave\" : \"valor\" , \"chave_int\" : 1 , \"chave_bool\" : true , \"uma_lista\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"um_dict\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 }, \"lista_inline\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"dict_inline\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 } }","title":"Arquivos YAML"},{"location":"05_playbooks/#nosso-primeiro-playbook","text":"Vamos reproduzir a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Ngix que fizemos via comandos ad-hoc no terminal: web_server.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- - name : Instala\u00e7\u00e3o do nginx hosts : linux # Grupo de hosts do invent\u00e1rio become : yes # Diz que vai escalonar privil\u00e9gios. Equivalente ao -b tasks : # Descri\u00e7\u00e3o das tarefas que ser\u00e3o executadas - name : Instala\u00e7\u00e3o do nginx # Nome da tarefa package : # Nome do m\u00f3dulo # Argumentos do m\u00f3dulo state : present name : nginx - name : Inicializa\u00e7\u00e3o do nginx systemd : state : started name : nginx Dessa forma, no lugar de executar um \u00fanico comando por vez, podemos disparar um playbook que executa diversas tarefas por vez: $ Execu\u00e7\u00e3o no terminal ansible-playbook web_server.yml Voc\u00ea deve ver uma grande resposta como essa: resposta do terminal ansible-playbook playbooks/web_server.yml PLAY [ Instala\u00e7\u00e3o do nginx ] ***************************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do nginx ] ***************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Inicializa\u00e7\u00e3o do nginx ] ************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ********************************************************************* 10 .0.2.15 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.16 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O que significa que o ansible conseguiu executar o playbook com sucesso.","title":"Nosso primeiro playbook"},{"location":"05_playbooks/#mais-um-playbook","text":"Sei que voc\u00ea j\u00e1 deve ter captado a ideia do playbook, mas que tal criarmos mais um? Vamos tentar reproduzir a configura\u00e7\u00e3o do emacs no localhost agora. Pois temos outros m\u00f3dulos e outros comandos para aprender: emacs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- - name : Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs hosts : localhost # Aqui mudamos para o localhost tasks : - name : Instala\u00e7\u00e3o do emacs become : yes # Diferente da outra config, somente esse passo ser\u00e1 como root package : state : present name : emacs - name : Instala\u00e7\u00e3o do git become : yes package : name : git state : present - name : Clone do nosso reposit\u00f3rio git : repo : https://github.com/dunossauro/dotfiles.git dest : config_files - name : Movendo os arquivos de configura\u00e7\u00e3o do emacs copy : dest : /home/vagrant/ src : /home/vagrant/config_files/.emacs.d Se executarmos esse playbook podemos ver algumas mensagens diferentes na resposta: $ Execu\u00e7\u00e3o no terminal ansible-playbook emacs.yml A resposta: resposta do terminal PLAY [ Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs ] ************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do emacs ] ***************************************************** ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do git ] ******************************************************* ok: [ localhost ] TASK [ Clone do nosso reposit\u00f3rio ] ********************************************** changed : [ localhost ] TASK [ Movendo os arquivos de configura\u00e7\u00e3o do emacs ] **************************** changed : [ localhost ] PLAY RECAP ********************************************************************* localhost : ok = 5 changed = 2 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O status changed apareceu. Significa que o resultado desse comando foi diferente da primeira vez que foi executado. O que quer dizer que alguma coisa mudou desde a ultima execu\u00e7\u00e3o. Provavelmente a resposta do ansible foi diferente pois o clone n\u00e3o foi feito, o diret\u00f3rio j\u00e1 existia e o move tamb\u00e9m j\u00e1 tinha sido feito antes.","title":"Mais um playbook"},{"location":"05_playbooks/#condicionais","text":"","title":"Condicionais"}]}