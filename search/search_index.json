{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Laborat\u00f3rio para Live de Python sobre Ansible O objetivo desse reposit\u00f3rio \u00e9 ajudar voc\u00ea a construir um laborat\u00f3rio para aprender Ansible. Aqui voc\u00ea vai encontrar dicas e passos para configurar suas m\u00e1quinas virtuais para construir seu ambiente. A minha ideia principal com essa live \u00e9 n\u00e3o depender de nenhum servi\u00e7o de nuvem. Nem todas as pessoas podem pagar ou tem cart\u00e3o de cr\u00e9dito para poder inserir mesmo nos planos gratuitos. Para n\u00e3o depender de servi\u00e7os externos, vamos usar m\u00e1quinas virtuais com virtualbox e vamos configur\u00e1-las usando Vagrant . Sum\u00e1rio 01 - Configura\u00e7\u00e3o do ambiente 02 - O b\u00e1sico necess\u00e1rio sobre Vagrant 03 - Ansible b\u00e1sico 04 - Entendendo a estrutura do Ansible 05 - Playbooks 06 - Taks","title":"Laborat\u00f3rio para Live de Python sobre Ansible :snake:"},{"location":"#laboratorio-para-live-de-python-sobre-ansible","text":"O objetivo desse reposit\u00f3rio \u00e9 ajudar voc\u00ea a construir um laborat\u00f3rio para aprender Ansible. Aqui voc\u00ea vai encontrar dicas e passos para configurar suas m\u00e1quinas virtuais para construir seu ambiente. A minha ideia principal com essa live \u00e9 n\u00e3o depender de nenhum servi\u00e7o de nuvem. Nem todas as pessoas podem pagar ou tem cart\u00e3o de cr\u00e9dito para poder inserir mesmo nos planos gratuitos. Para n\u00e3o depender de servi\u00e7os externos, vamos usar m\u00e1quinas virtuais com virtualbox e vamos configur\u00e1-las usando Vagrant .","title":"Laborat\u00f3rio para Live de Python sobre Ansible"},{"location":"#sumario","text":"01 - Configura\u00e7\u00e3o do ambiente 02 - O b\u00e1sico necess\u00e1rio sobre Vagrant 03 - Ansible b\u00e1sico 04 - Entendendo a estrutura do Ansible 05 - Playbooks 06 - Taks","title":"Sum\u00e1rio"},{"location":"01_configuracao_do_ambiente/","text":"Configura\u00e7\u00e3o do ambiente A primeira coisa que precisamos fazer \u00e9 configurar o nosso host para instala\u00e7\u00e3o das m\u00e1quinas virtuais. Para isso, precisamos instalar o virtualbox e o vagrant . Instala\u00e7\u00e3o do virtualbox Virtualbox \u00e9 um software para cria\u00e7\u00e3o de m\u00e1quinas virtuais. E ele pode ser instalado em qualquer plataforma comum do mercado. Como Windows, Linux e MacOS. Caso voc\u00ea use o windows, as instala\u00e7\u00f5es podem ser feitas via chocolatey Voc\u00ea pode fazer o download e instalar ou instalar usando o seu gerenciador de pacotes usando seu terminal preferido: paru -S virtualbox # Arch choco install virtualbox # Windows sudo apt-get install virtualbox # Ubuntu Instala\u00e7\u00e3o do vagrant Vagrant \u00e9 um software de c\u00f3digo aberto, escrito em Ruby para construir ambientes de desenvolvimento usando um arquivo de configura\u00e7\u00e3o. Que pode ser reproduzido por qualquer pessoa que tenha acesso ao arquivo. Abra seu terminal preferido e fa\u00e7a a instala\u00e7\u00e3o: paru -S vagrant # Arch choco install vagrant # Windows sudo apt install vagrant # Ubuntu","title":"Configura\u00e7\u00e3o do ambiente"},{"location":"01_configuracao_do_ambiente/#configuracao-do-ambiente","text":"A primeira coisa que precisamos fazer \u00e9 configurar o nosso host para instala\u00e7\u00e3o das m\u00e1quinas virtuais. Para isso, precisamos instalar o virtualbox e o vagrant .","title":"Configura\u00e7\u00e3o do ambiente"},{"location":"01_configuracao_do_ambiente/#instalacao-do-virtualbox","text":"Virtualbox \u00e9 um software para cria\u00e7\u00e3o de m\u00e1quinas virtuais. E ele pode ser instalado em qualquer plataforma comum do mercado. Como Windows, Linux e MacOS. Caso voc\u00ea use o windows, as instala\u00e7\u00f5es podem ser feitas via chocolatey Voc\u00ea pode fazer o download e instalar ou instalar usando o seu gerenciador de pacotes usando seu terminal preferido: paru -S virtualbox # Arch choco install virtualbox # Windows sudo apt-get install virtualbox # Ubuntu","title":"Instala\u00e7\u00e3o do virtualbox"},{"location":"01_configuracao_do_ambiente/#instalacao-do-vagrant","text":"Vagrant \u00e9 um software de c\u00f3digo aberto, escrito em Ruby para construir ambientes de desenvolvimento usando um arquivo de configura\u00e7\u00e3o. Que pode ser reproduzido por qualquer pessoa que tenha acesso ao arquivo. Abra seu terminal preferido e fa\u00e7a a instala\u00e7\u00e3o: paru -S vagrant # Arch choco install vagrant # Windows sudo apt install vagrant # Ubuntu","title":"Instala\u00e7\u00e3o do vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/","text":"B\u00e1sico necess\u00e1rio sobre Vagrant Vagrant \u00e9 uma ferramenta para provisionamento de m\u00e1quinas virtuais. Dizendo de forma simples, ele cria e configura m\u00e1quinas virtuais usando um arquivo de configura\u00e7\u00e3o chamado Vagrantfile . Nesse arquivo podemos descrever como nossas vms ser\u00e3o configuradas. Exemplo de um arquivo do Vagrant: Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end A linha destacada \u00e9 referente a um box do Vagrant. Vagrant boxes Um box do vagrant no nosso contexto \u00e9 uma m\u00e1quina virtual pr\u00e9-fabricada por uma pessoa. Existem milhares delas e elas podem ser acessadas no Vagrant Cloud Eu optei por usar m\u00e1quina do arch linux para iniciarmos nossa configura\u00e7\u00e3o. Criando uma m\u00e1quina virtual Nosso primeiro passado \u00e9 copiar o seguinte Vagrantfile : Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end e colocar no diret\u00f3rio do nosso projeto. Que vamos inicialmente chamar de ansible-lab . Dessa forma podemos criar nossa m\u00e1quina virtual usando um simples comando: $ Execu\u00e7\u00e3o no terminal vagrant up O resultado deve ser algo parecido com isso: Bringing machine 'default' up with 'virtualbox' provider... == > default: Importing base box 'archlinux/archlinux' ... == > default: Matching MAC address for NAT networking... == > default: Checking if box 'archlinux/archlinux' version '20221101.99038' is up to date... == > default: Setting the name of the VM: ansible_lab_default_1668393945684_70462 == > default: Clearing any previously set network interfaces... == > default: Preparing network interfaces based on configuration... default: Adapter 1 : nat == > default: Forwarding ports... default: 22 ( guest ) = > 2222 ( host ) ( adapter 1 ) == > default: Booting VM... == > default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127 .0.0.1:2222 default: SSH username: vagrant default: SSH auth method: private key default: Warning: Connection reset. Retrying... default: Warning: Remote connection disconnect. Retrying... default: default: Vagrant insecure key detected. Vagrant will automatically replace default: this with a newly generated keypair for better security. default: default: Inserting generated public key within guest... default: Removing insecure key from the guest if it ' s present... default: Key inserted! Disconnecting and reconnecting using new SSH key... == > default: Machine booted and ready! == > default: Checking for guest additions in VM... == > default: Mounting shared folders... default: /vagrant = > /home/z4r4tu5tr4/ansible_lab E ele criar\u00e1 uma m\u00e1quina virtual com archlinux no nosso virtualbox. OBS: Esse comando pode demorar um pouco pois ele vai baixar um hd virtual do archlinux e instalar no seu virtualbox. Agora que temos uma m\u00e1quina virtual podemos partir para o segundo passo. Que \u00e9 criar dois n\u00f3s para trabalhar com ansible. Destruindo a m\u00e1quina criada Caso voc\u00ea tenha problemas ou queira simplesmente destruir a m\u00e1quina virutal. O vagrant pode destruir de forma simples a vm e \u00e9 isso que faremos agora. vagrant destroy Com isso podemos ter nosso ambiente limpo outra vez: Configurando mais de uma m\u00e1quina virtual Agora que entendemos a din\u00e2mica de cria\u00e7\u00e3o de vms do vagrant, podemos configurar duas m\u00e1quinas para o ansible. Uma que vamos chamar de main que ser\u00e1 de onde chamaremos o ansible e uma que ser\u00e1 controlada por ele. Que se chamar\u00e1 somente arch . Para isso, s\u00f3 precisamos alterar nosso Vagrantfile : Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end end Agora temos duas m\u00e1quinas virtuais. Uma configurada com Archlinux e uma com Ubuntu Linux. Por\u00e9m cada uma tem uma fun\u00e7\u00e3o diferente na nossa rede. O vagrant pode subir uma \u00fanica vm ou as duas de uma vez: vagrant up # Inicia as duas vms vagrant up ubuntu # Somente a m\u00e1quina ubuntu vagrant up main # Somente a m\u00e1quina main (vamos escolher essa op\u00e7\u00e3o)","title":"B\u00e1sico necess\u00e1rio sobre Vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/#basico-necessario-sobre-vagrant","text":"Vagrant \u00e9 uma ferramenta para provisionamento de m\u00e1quinas virtuais. Dizendo de forma simples, ele cria e configura m\u00e1quinas virtuais usando um arquivo de configura\u00e7\u00e3o chamado Vagrantfile . Nesse arquivo podemos descrever como nossas vms ser\u00e3o configuradas. Exemplo de um arquivo do Vagrant: Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end A linha destacada \u00e9 referente a um box do Vagrant.","title":"B\u00e1sico necess\u00e1rio sobre Vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/#vagrant-boxes","text":"Um box do vagrant no nosso contexto \u00e9 uma m\u00e1quina virtual pr\u00e9-fabricada por uma pessoa. Existem milhares delas e elas podem ser acessadas no Vagrant Cloud Eu optei por usar m\u00e1quina do arch linux para iniciarmos nossa configura\u00e7\u00e3o.","title":"Vagrant boxes"},{"location":"02_o_basico_necessario_sobre_vagrant/#criando-uma-maquina-virtual","text":"Nosso primeiro passado \u00e9 copiar o seguinte Vagrantfile : Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end e colocar no diret\u00f3rio do nosso projeto. Que vamos inicialmente chamar de ansible-lab . Dessa forma podemos criar nossa m\u00e1quina virtual usando um simples comando: $ Execu\u00e7\u00e3o no terminal vagrant up O resultado deve ser algo parecido com isso: Bringing machine 'default' up with 'virtualbox' provider... == > default: Importing base box 'archlinux/archlinux' ... == > default: Matching MAC address for NAT networking... == > default: Checking if box 'archlinux/archlinux' version '20221101.99038' is up to date... == > default: Setting the name of the VM: ansible_lab_default_1668393945684_70462 == > default: Clearing any previously set network interfaces... == > default: Preparing network interfaces based on configuration... default: Adapter 1 : nat == > default: Forwarding ports... default: 22 ( guest ) = > 2222 ( host ) ( adapter 1 ) == > default: Booting VM... == > default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127 .0.0.1:2222 default: SSH username: vagrant default: SSH auth method: private key default: Warning: Connection reset. Retrying... default: Warning: Remote connection disconnect. Retrying... default: default: Vagrant insecure key detected. Vagrant will automatically replace default: this with a newly generated keypair for better security. default: default: Inserting generated public key within guest... default: Removing insecure key from the guest if it ' s present... default: Key inserted! Disconnecting and reconnecting using new SSH key... == > default: Machine booted and ready! == > default: Checking for guest additions in VM... == > default: Mounting shared folders... default: /vagrant = > /home/z4r4tu5tr4/ansible_lab E ele criar\u00e1 uma m\u00e1quina virtual com archlinux no nosso virtualbox. OBS: Esse comando pode demorar um pouco pois ele vai baixar um hd virtual do archlinux e instalar no seu virtualbox. Agora que temos uma m\u00e1quina virtual podemos partir para o segundo passo. Que \u00e9 criar dois n\u00f3s para trabalhar com ansible.","title":"Criando uma m\u00e1quina virtual"},{"location":"02_o_basico_necessario_sobre_vagrant/#destruindo-a-maquina-criada","text":"Caso voc\u00ea tenha problemas ou queira simplesmente destruir a m\u00e1quina virutal. O vagrant pode destruir de forma simples a vm e \u00e9 isso que faremos agora. vagrant destroy Com isso podemos ter nosso ambiente limpo outra vez:","title":"Destruindo a m\u00e1quina criada"},{"location":"02_o_basico_necessario_sobre_vagrant/#configurando-mais-de-uma-maquina-virtual","text":"Agora que entendemos a din\u00e2mica de cria\u00e7\u00e3o de vms do vagrant, podemos configurar duas m\u00e1quinas para o ansible. Uma que vamos chamar de main que ser\u00e1 de onde chamaremos o ansible e uma que ser\u00e1 controlada por ele. Que se chamar\u00e1 somente arch . Para isso, s\u00f3 precisamos alterar nosso Vagrantfile : Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end end Agora temos duas m\u00e1quinas virtuais. Uma configurada com Archlinux e uma com Ubuntu Linux. Por\u00e9m cada uma tem uma fun\u00e7\u00e3o diferente na nossa rede. O vagrant pode subir uma \u00fanica vm ou as duas de uma vez: vagrant up # Inicia as duas vms vagrant up ubuntu # Somente a m\u00e1quina ubuntu vagrant up main # Somente a m\u00e1quina main (vamos escolher essa op\u00e7\u00e3o)","title":"Configurando mais de uma m\u00e1quina virtual"},{"location":"03_ansible_basico/","text":"Ansible b\u00e1sico Ansible \u00e9 um grupo de ferramentas de c\u00f3digo aberto constru\u00eddas em python. O objetivo do Ansible \u00e9 automatizar tarefas de diversas naturezas. Foi originalmente escrito por Michael DeHaan em 2012 e foi comprado pela Red Hat em 2015. curiosidade A palavra Ansible foi cunhada por Ursula K. Le Guin no livro O mundo de Rocannon No livro existem diversos mundos e viajantes navegam na velocidade da luz. Ansible \u00e9 um dispositivo que de comunica\u00e7\u00e3o de comunica\u00e7\u00e3o instant\u00e2nea pelo universo. Automa\u00e7\u00f5es Quando falamos sobre Ansible, estamos falando sobre qualquer tipo de automa\u00e7\u00e3o em m\u00e1quinas. Alguns exemplos comuns s\u00e3o: Provisionamento de ambientes Gerenciamento de configura\u00e7\u00e3o Implanta\u00e7\u00e3o de aplicativos Entre outras coisas que podemos fazer com o ferramental Provisionamento Provisionamento \u00e9 o processo de preparar um dispositivo para que ele possa entrar em produ\u00e7\u00e3o. N\u00e3o s\u00f3 exatamente a respeito do hardware, mas a prepara\u00e7\u00e3o do sistema operacional a escolha dos aplicativos instalados e etc... Vimos nesse pequeno tutorial outra ferramenta de provisionamento, o Vagrant, que consegue montar a m\u00e1quina virtual, fornecer a instala\u00e7\u00e3o do sistema operacional. A parte que envolve o ansible \u00e9 mais referente a configura\u00e7\u00e3o dos pacotes instalados, a instala\u00e7\u00e3o dos softwares necess\u00e1rios para colocar uma m\u00e1quina, geralmente um servidor, em funcionamento. Gerenciamento de configura\u00e7\u00e3o O gerenciamento de configura\u00e7\u00e3o \u00e9 uma das partes do provisionamento, por\u00e9m com foco e configurar as aplica\u00e7\u00f5es instaladas no sistema operacional para que ele se comporte como esperado em produ\u00e7\u00e3o. Implanta\u00e7\u00e3o de aplicativos Ap\u00f3s toda a fase de instala\u00e7\u00e3o e configura\u00e7\u00e3o do ambiente e do sistema operacional, podemos colocar nossos aplicativos para serem executados nessas m\u00e1quinas. Um exemplo Vamos pensar que fizemos uma aplica\u00e7\u00e3o web com Python. Para que essa aplica\u00e7\u00e3o seja usada em um servidor o servidor tem que atender diversos requisitos para executar a nossa aplica\u00e7\u00e3o. Independentemente da op\u00e7\u00e3o que voc\u00ea escolha para fazer o deploy dela. De forma simples, temos que instalar o python na vers\u00e3o correta, fazer a instala\u00e7\u00e3o das bibliotecas necess\u00e1rias, configurar um banco de dados. Fazer com que a aplica\u00e7\u00e3o e o banco de dados conversem. Para que isso ocorra na nuvem, por exemplo, algu\u00e9m deve ter provisionado um sistema base, como um ubuntu linux , geralmente usando algum sistema de virtualiza\u00e7\u00e3o. Como fizemos aqui com VirtualBox, por\u00e9m em uma escala muito maior. Essa m\u00e1quina tem que ter ao menos um servi\u00e7o de SSH configurado para que possamos acessar esse computador do conforto da nossa casa. \u00c9 nesse contexto que o Ansible entra. Pegamos um sistema operacional limpo e iniciamos as nossas configura\u00e7\u00f5es e instala\u00e7\u00f5es para que nossa aplica\u00e7\u00e3o possa ser executada nesse servidor. Instala\u00e7\u00e3o do ansible Agora que temos duas m\u00e1quinas virtuais criadas. Podemos come\u00e7ar a instala\u00e7\u00e3o do ansible. A primeira coisa que devemos fazer \u00e9 acessar a m\u00e1quina controladora. Para isso podemos usar o vagrant para nos ajudar: vagrant up main # Iniciar a m\u00e1quina controladora vagrant ssh main # Acessar o console da m\u00e1quina controladora via ssh E isso deve retornar o console d\u00e1 maquina controladora no usu\u00e1rio vagrant : O ansible tem seus pacotes nos reposit\u00f3rios de quase todas as distribui\u00e7\u00f5es linux. Ent\u00e3o voc\u00ea pode instalar no seu sistema como quiser. Caso tenha d\u00favidas, o link da documenta\u00e7\u00e3o Formas de instalar em diversos sistemas. sudo pacman -S ansible # Arch sudo apt install ansible # Ubuntu sudo dnf ansible # Familia Redhat O ansible tamb\u00e9m pode ser instalado via pip , por\u00e9m a instala\u00e7\u00e3o \u00e9 bastante trabalhosa. Como eu escolhi que a m\u00e1quina main fosse um archlinux, vamos seguir a configura\u00e7\u00e3o com ele. O primeiro passo que devemos fazer \u00e9 atualizar a m\u00e1quina para garantir que tudo funcione como o esperado: sudo pacman -Syu # Atualiza o sistema Caso a senha senha perguntada. A senha padr\u00e3o criada pelas m\u00e1quinas virtuais do vagrant \u00e9 vagrant . Agora podemos rodar o comando para instalar o ansible: sudo pacman -S ansible Se tudo ocorrer como o esperado, podemos perguntar a vers\u00e3o do ansible ao sistema: [ vagrant@archlinux ~ ] $ ansible --version ansible [ core 2 .14.0 ] config file = /etc/ansible/ansible.cfg configured module search path = [ '/home/vagrant/.ansible/plugins/modules' , '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/lib/python3.10/site-packages/ansible ansible collection location = /home/vagrant/.ansible/collections:/usr/share/ansible/collections executable location = /usr/bin/ansible python version = 3 .10.8 ( main, Nov 1 2022 , 14 :18:21 ) [ GCC 12 .2.0 ] ( /usr/bin/python ) jinja version = 3 .1.2 libyaml = True Ele nos disse que est\u00e1 na vers\u00e3o 3.10.8 Um pouco de ansible na pr\u00e1tica O ansible foi pensado para que pud\u00e9ssemos automatizar uma tarefa de qualquer natureza. Para isso basta ter o ansible instalado na sua m\u00e1quina e cham\u00e1-lo via linha de comando. Instala\u00e7\u00e3o de um pacote Por exemplo, vamos supor que no nosso ambiente \u00e9 imprescind\u00edvel que o editor de texto GNU/Emacs esteja instalado (para mim costuma ser). Ent\u00e3o podemos usar o ansible para instalar o Emacs no nosso computador pessoal: $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=emacs state=present\" -b Com esse simples comando, temos o GNU/Emacs instalado nesse computador. Mas, o que realmente aconteceu aqui? Fragmento do comando O que faz? ansible Invoca o ansible localhost Diz qual m\u00e1quina ser\u00e1 afetada pelo comando -m Diz que vamos chamar um m\u00f3dulo package package \u00e9 o nome do m\u00f3dulo que vamos chamar -a Indica que vamos passar argumentos para o m\u00f3dulo \"name=emacs state=present\" Argumentos do m\u00f3dulo -b Diz ao Ansible que o comando ser\u00e1 executado como root O m\u00f3dulo package \u00e9 um dos muitos m\u00f3dulos ofertados pelo Ansible. Voc\u00ea pode ver uma lista completa aqui nesse link . O que dissemos por\u00e9m \u00e9: \"Modulo package garanta que o pacote emacs esteja presente no sistema em que for executado\". Podemos checar no terminal: $ Execu\u00e7\u00e3o no terminal emacs Caso tenha ficado preso Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs Configura\u00e7\u00e3o do pacote Embora o GNU/Emacs esteja instalado no meu sistema. Ele ainda n\u00e3o foi configurado da maneira que eu gostaria. N\u00e3o tem as minhas cores, os meus atalhos e para isso precisamos baixar meu arquivo de configura\u00e7\u00e3o que est\u00e1 no github.com/dunossauro/dotfiles . Para isso, podemos contar com outro m\u00f3dulo dispon\u00edvel no Ansible, o git . Ent\u00e3o, vamos baixar as minhas configura\u00e7\u00f5es: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" E com isso, obtivemos um erro: Resposta do terminal localhost | FAILED! = > { \"changed\" : false, \"msg\" : \"Failed to find required executable \\\"git\\\" in paths: /usr/local/sbin:/usr/local/bin:/usr/bin:/sbin:/usr/sbin\" } O ansible n\u00e3o conseguiu achar o git no nosso sistema, ele precisa ser instalado. Como j\u00e1 conhecemos o m\u00f3dulo package, ser\u00e1 f\u00e1cil. S\u00f3 dizer ao m\u00f3dulo package que git deve estar present : $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=git state=present\" -b Ap\u00f3s instalar o git, podemos testar nosso m\u00f3dulo de git outra vez: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" Resposta do terminal localhost | CHANGED = > { \"after\" : \"8ff42a43ede85403b6b85c0bab9a1a4fe0d73544\" , \"before\" : null, \"changed\" : true } CHANGED , significa que uma a\u00e7\u00e3o foi executada e agora temos os arquivos no nosso computador na pasta dest que passamos como argumento. $ Execu\u00e7\u00e3o no terminal ls config_files/.emacs.d init.el Agora s\u00f3 falta colocar a nossa configura\u00e7\u00e3o no lugar certo. O diret\u00f3rio ~/.emacs.d/ . Para isso podemos contar com outro m\u00f3dulo do copy : $ Execu\u00e7\u00e3o no terminal ansible localhost -m copy -a \"dest='/home/vagrant/' src='/home/vagrant/config_files/.emacs.d'\" Ap\u00f3s isso, podemos abrir o emacs novamente: $ Execu\u00e7\u00e3o no terminal emacs Pode demorar um pouco para as configura\u00e7\u00f5es serem baixadas e instaladas da internet. E temos o emacs com as minhas configura\u00e7\u00f5es: Caso tenha ficado preso OUTRA VEZ Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Ansible b\u00e1sico"},{"location":"03_ansible_basico/#ansible-basico","text":"Ansible \u00e9 um grupo de ferramentas de c\u00f3digo aberto constru\u00eddas em python. O objetivo do Ansible \u00e9 automatizar tarefas de diversas naturezas. Foi originalmente escrito por Michael DeHaan em 2012 e foi comprado pela Red Hat em 2015. curiosidade A palavra Ansible foi cunhada por Ursula K. Le Guin no livro O mundo de Rocannon No livro existem diversos mundos e viajantes navegam na velocidade da luz. Ansible \u00e9 um dispositivo que de comunica\u00e7\u00e3o de comunica\u00e7\u00e3o instant\u00e2nea pelo universo.","title":"Ansible b\u00e1sico"},{"location":"03_ansible_basico/#automacoes","text":"Quando falamos sobre Ansible, estamos falando sobre qualquer tipo de automa\u00e7\u00e3o em m\u00e1quinas. Alguns exemplos comuns s\u00e3o: Provisionamento de ambientes Gerenciamento de configura\u00e7\u00e3o Implanta\u00e7\u00e3o de aplicativos Entre outras coisas que podemos fazer com o ferramental","title":"Automa\u00e7\u00f5es"},{"location":"03_ansible_basico/#provisionamento","text":"Provisionamento \u00e9 o processo de preparar um dispositivo para que ele possa entrar em produ\u00e7\u00e3o. N\u00e3o s\u00f3 exatamente a respeito do hardware, mas a prepara\u00e7\u00e3o do sistema operacional a escolha dos aplicativos instalados e etc... Vimos nesse pequeno tutorial outra ferramenta de provisionamento, o Vagrant, que consegue montar a m\u00e1quina virtual, fornecer a instala\u00e7\u00e3o do sistema operacional. A parte que envolve o ansible \u00e9 mais referente a configura\u00e7\u00e3o dos pacotes instalados, a instala\u00e7\u00e3o dos softwares necess\u00e1rios para colocar uma m\u00e1quina, geralmente um servidor, em funcionamento.","title":"Provisionamento"},{"location":"03_ansible_basico/#gerenciamento-de-configuracao","text":"O gerenciamento de configura\u00e7\u00e3o \u00e9 uma das partes do provisionamento, por\u00e9m com foco e configurar as aplica\u00e7\u00f5es instaladas no sistema operacional para que ele se comporte como esperado em produ\u00e7\u00e3o.","title":"Gerenciamento de configura\u00e7\u00e3o"},{"location":"03_ansible_basico/#implantacao-de-aplicativos","text":"Ap\u00f3s toda a fase de instala\u00e7\u00e3o e configura\u00e7\u00e3o do ambiente e do sistema operacional, podemos colocar nossos aplicativos para serem executados nessas m\u00e1quinas.","title":"Implanta\u00e7\u00e3o de aplicativos"},{"location":"03_ansible_basico/#um-exemplo","text":"Vamos pensar que fizemos uma aplica\u00e7\u00e3o web com Python. Para que essa aplica\u00e7\u00e3o seja usada em um servidor o servidor tem que atender diversos requisitos para executar a nossa aplica\u00e7\u00e3o. Independentemente da op\u00e7\u00e3o que voc\u00ea escolha para fazer o deploy dela. De forma simples, temos que instalar o python na vers\u00e3o correta, fazer a instala\u00e7\u00e3o das bibliotecas necess\u00e1rias, configurar um banco de dados. Fazer com que a aplica\u00e7\u00e3o e o banco de dados conversem. Para que isso ocorra na nuvem, por exemplo, algu\u00e9m deve ter provisionado um sistema base, como um ubuntu linux , geralmente usando algum sistema de virtualiza\u00e7\u00e3o. Como fizemos aqui com VirtualBox, por\u00e9m em uma escala muito maior. Essa m\u00e1quina tem que ter ao menos um servi\u00e7o de SSH configurado para que possamos acessar esse computador do conforto da nossa casa. \u00c9 nesse contexto que o Ansible entra. Pegamos um sistema operacional limpo e iniciamos as nossas configura\u00e7\u00f5es e instala\u00e7\u00f5es para que nossa aplica\u00e7\u00e3o possa ser executada nesse servidor.","title":"Um exemplo"},{"location":"03_ansible_basico/#instalacao-do-ansible","text":"Agora que temos duas m\u00e1quinas virtuais criadas. Podemos come\u00e7ar a instala\u00e7\u00e3o do ansible. A primeira coisa que devemos fazer \u00e9 acessar a m\u00e1quina controladora. Para isso podemos usar o vagrant para nos ajudar: vagrant up main # Iniciar a m\u00e1quina controladora vagrant ssh main # Acessar o console da m\u00e1quina controladora via ssh E isso deve retornar o console d\u00e1 maquina controladora no usu\u00e1rio vagrant : O ansible tem seus pacotes nos reposit\u00f3rios de quase todas as distribui\u00e7\u00f5es linux. Ent\u00e3o voc\u00ea pode instalar no seu sistema como quiser. Caso tenha d\u00favidas, o link da documenta\u00e7\u00e3o Formas de instalar em diversos sistemas. sudo pacman -S ansible # Arch sudo apt install ansible # Ubuntu sudo dnf ansible # Familia Redhat O ansible tamb\u00e9m pode ser instalado via pip , por\u00e9m a instala\u00e7\u00e3o \u00e9 bastante trabalhosa. Como eu escolhi que a m\u00e1quina main fosse um archlinux, vamos seguir a configura\u00e7\u00e3o com ele. O primeiro passo que devemos fazer \u00e9 atualizar a m\u00e1quina para garantir que tudo funcione como o esperado: sudo pacman -Syu # Atualiza o sistema Caso a senha senha perguntada. A senha padr\u00e3o criada pelas m\u00e1quinas virtuais do vagrant \u00e9 vagrant . Agora podemos rodar o comando para instalar o ansible: sudo pacman -S ansible Se tudo ocorrer como o esperado, podemos perguntar a vers\u00e3o do ansible ao sistema: [ vagrant@archlinux ~ ] $ ansible --version ansible [ core 2 .14.0 ] config file = /etc/ansible/ansible.cfg configured module search path = [ '/home/vagrant/.ansible/plugins/modules' , '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/lib/python3.10/site-packages/ansible ansible collection location = /home/vagrant/.ansible/collections:/usr/share/ansible/collections executable location = /usr/bin/ansible python version = 3 .10.8 ( main, Nov 1 2022 , 14 :18:21 ) [ GCC 12 .2.0 ] ( /usr/bin/python ) jinja version = 3 .1.2 libyaml = True Ele nos disse que est\u00e1 na vers\u00e3o 3.10.8","title":"Instala\u00e7\u00e3o do ansible"},{"location":"03_ansible_basico/#um-pouco-de-ansible-na-pratica","text":"O ansible foi pensado para que pud\u00e9ssemos automatizar uma tarefa de qualquer natureza. Para isso basta ter o ansible instalado na sua m\u00e1quina e cham\u00e1-lo via linha de comando.","title":"Um pouco de ansible na pr\u00e1tica"},{"location":"03_ansible_basico/#instalacao-de-um-pacote","text":"Por exemplo, vamos supor que no nosso ambiente \u00e9 imprescind\u00edvel que o editor de texto GNU/Emacs esteja instalado (para mim costuma ser). Ent\u00e3o podemos usar o ansible para instalar o Emacs no nosso computador pessoal: $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=emacs state=present\" -b Com esse simples comando, temos o GNU/Emacs instalado nesse computador. Mas, o que realmente aconteceu aqui? Fragmento do comando O que faz? ansible Invoca o ansible localhost Diz qual m\u00e1quina ser\u00e1 afetada pelo comando -m Diz que vamos chamar um m\u00f3dulo package package \u00e9 o nome do m\u00f3dulo que vamos chamar -a Indica que vamos passar argumentos para o m\u00f3dulo \"name=emacs state=present\" Argumentos do m\u00f3dulo -b Diz ao Ansible que o comando ser\u00e1 executado como root O m\u00f3dulo package \u00e9 um dos muitos m\u00f3dulos ofertados pelo Ansible. Voc\u00ea pode ver uma lista completa aqui nesse link . O que dissemos por\u00e9m \u00e9: \"Modulo package garanta que o pacote emacs esteja presente no sistema em que for executado\". Podemos checar no terminal: $ Execu\u00e7\u00e3o no terminal emacs Caso tenha ficado preso Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Instala\u00e7\u00e3o de um pacote"},{"location":"03_ansible_basico/#configuracao-do-pacote","text":"Embora o GNU/Emacs esteja instalado no meu sistema. Ele ainda n\u00e3o foi configurado da maneira que eu gostaria. N\u00e3o tem as minhas cores, os meus atalhos e para isso precisamos baixar meu arquivo de configura\u00e7\u00e3o que est\u00e1 no github.com/dunossauro/dotfiles . Para isso, podemos contar com outro m\u00f3dulo dispon\u00edvel no Ansible, o git . Ent\u00e3o, vamos baixar as minhas configura\u00e7\u00f5es: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" E com isso, obtivemos um erro: Resposta do terminal localhost | FAILED! = > { \"changed\" : false, \"msg\" : \"Failed to find required executable \\\"git\\\" in paths: /usr/local/sbin:/usr/local/bin:/usr/bin:/sbin:/usr/sbin\" } O ansible n\u00e3o conseguiu achar o git no nosso sistema, ele precisa ser instalado. Como j\u00e1 conhecemos o m\u00f3dulo package, ser\u00e1 f\u00e1cil. S\u00f3 dizer ao m\u00f3dulo package que git deve estar present : $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=git state=present\" -b Ap\u00f3s instalar o git, podemos testar nosso m\u00f3dulo de git outra vez: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" Resposta do terminal localhost | CHANGED = > { \"after\" : \"8ff42a43ede85403b6b85c0bab9a1a4fe0d73544\" , \"before\" : null, \"changed\" : true } CHANGED , significa que uma a\u00e7\u00e3o foi executada e agora temos os arquivos no nosso computador na pasta dest que passamos como argumento. $ Execu\u00e7\u00e3o no terminal ls config_files/.emacs.d init.el Agora s\u00f3 falta colocar a nossa configura\u00e7\u00e3o no lugar certo. O diret\u00f3rio ~/.emacs.d/ . Para isso podemos contar com outro m\u00f3dulo do copy : $ Execu\u00e7\u00e3o no terminal ansible localhost -m copy -a \"dest='/home/vagrant/' src='/home/vagrant/config_files/.emacs.d'\" Ap\u00f3s isso, podemos abrir o emacs novamente: $ Execu\u00e7\u00e3o no terminal emacs Pode demorar um pouco para as configura\u00e7\u00f5es serem baixadas e instaladas da internet. E temos o emacs com as minhas configura\u00e7\u00f5es: Caso tenha ficado preso OUTRA VEZ Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Configura\u00e7\u00e3o do pacote"},{"location":"04_configuracao_do_ansible/","text":"Entendendo a estrutura do ansible Embora at\u00e9 o momento executamos o ansible somente em uma m\u00e1quina local. E confesso que j\u00e1 pode ser bastante \u00fatil para padronizar suas configura\u00e7\u00f5es ap\u00f3s uma formata\u00e7\u00e3o, por exemplo. O Ansible brilha quando estamos falando de rede. Arquitetura de uso do ansible O Ansible distingue as m\u00e1quinas em duas categorias. O n\u00f3 de controle, onde o ansible est\u00e1 instalado e os n\u00f3s controlados. Que m\u00e1quinas em que o ansible pode se comunicar via SSH e executar os comandos: Dessa forma podemos partir do n\u00f3 de Controle e enviar rotinas de automa\u00e7\u00e3o para todos os n\u00f3s Controlados . Para isso o ansible conta com um arquivo de invent\u00e1rio. Um lugar onde todas as m\u00e1quinas que ser\u00e3o controladas pelo controlador devem ser registradas. Arquivo de invent\u00e1rio Por padr\u00e3o o arquivo de invent\u00e1rio das m\u00e1quinas ficam no /etc/ansible/hosts . Vamos criar esse arquivo agora. $ Execu\u00e7\u00e3o no terminal # instala\u00e7\u00e3o do Nano, n\u00e3o vou obrigar ningu\u00e9m a usar o Emacs ;) ansible localhost -m package -a \"name=emacs state=present\" -b sudo nano /etc/ansible/hosts \u00c9 nesse arquivo que colocamos os endere\u00e7os dos n\u00f3s que ser\u00e3o controlados pelo ansible. O arquivo tem o seguinte formato: [<nome_do_grupo>] <endere\u00e7o_da_maquina> <op\u00e7\u00f5es> Por exemplo, vamos cadastrar nossa outra vm arch que ser\u00e1 controlado pelo main . Para isso, precisamos iniciar essa m\u00e1quina virtual. Antes disso, temos que sair do ssh em main : $ Execu\u00e7\u00e3o no terminal exit Agora voltamos a maquina principal. A m\u00e1quina onde as m\u00e1quinas virtuais foram instaladas. Vamos iniciar nossa outra m\u00e1quina. O ubuntu : vagrant up ubuntu Com isso, agora devemos ter duas m\u00e1quinas no nosso virtual box: [AA] - Mudar essa imagem Com nossa vm j\u00e1 de p\u00e9, podemos enviar um comando para o vagrant nos dizer o endere\u00e7o ip da m\u00e1quina ubuntu : $ Execu\u00e7\u00e3o no terminal vagrant ssh ubuntu -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.15 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Podemos ver que o IP associado a ubuntu \u00e9 10.0.2.15 . Que \u00e9 o endere\u00e7o que colocaremos no nosso invent\u00e1rio. Agora vamos voltar a nossa m\u00e1quina main via ssh: $ Execu\u00e7\u00e3o no terminal vagrant ssh main E vamos alterar nosso arquivo /etc/ansible/hosts dessa forma e com o comando sudo nano /etc/ansible/hosts : /etc/ansible/hosts 1 2 [ubuntu] 10.0.2.15 Dessa forma dissemos ao ansible que existe um grupo chamado ubuntu , uma dessas m\u00e1quinas tem o ip 10.0.2.15 . Assim, podemos enviar comandos para o grupo ubuntu . Primeiro comando remoto E podemos checar enviando um ping para a vm ubuntu usando o seguinte comando ansible ubuntu -m ping : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m ping The authenticity of host '10.0.2.15 (10.0.2.15)' can 't be established. ED25519 key fingerprint is SHA256:FyOy2yTlOHSLJXVF+lmYjPywdfmQprApMWrsQ7KxUlI. This host key is known by the following other names/addresses: ~/.ssh/known_hosts:1: localhost Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 10.0.2.15 | UNREACHABLE! => { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: Warning: Permanently added ' 10 .0.2.15 ' ( ED25519 ) to the list of known hosts. \\r\\n vagrant@10.0.2.15: Permission denied ( publickey,password ) . \", \" unreachable \": true } Um erro ocorreu por conta da seguran\u00e7a. O SSH da vm ubuntu n\u00e3o permitiu que o ansible fizesse a conex\u00e3o. Para isso precisamos trocar chaves entre os hosts para que aconte\u00e7a de maneira segura. Troca de chaves SSH Vamos voltar ao shell e digitar os seguintes comandos: $ Execu\u00e7\u00e3o no terminal ssh-keygen # para gerar uma chave ssh para nossa vm `main` ssh-copy-id vagrant@10.0.2.15 # Para copiar a chave de `main` para `ubuntu` Se executarmos o ping novamente obteremos sucesso: $ Execu\u00e7\u00e3o no terminal ansible arch -m ping 10 .0.2.15 | SUCCESS = > { \"ansible_facts\" : { \"discovered_interpreter_python\" : \"/usr/bin/python3.10\" } , \"changed\" : false, \"ping\" : \"pong\" } Isso significa que a comunica\u00e7\u00e3o com os dois n\u00f3s est\u00e1 acontecendo de maneira correta. Mas, faltou entender o que o comando ansible ubuntu -m ping significa: ansible: Chama o ansible ubuntu: O nome do grupo do invent\u00e1rio -m: Significa que vamos chamar um m\u00f3dulo ping: M\u00f3dulo para checar se o grupo est\u00e1 respondendo Repetindo o processo para mais uma m\u00e1quina Agora que j\u00e1 entendemos o que temos que fazer. Podemos adicionar mais uma m\u00e1quina virtual ao nosso ambiente. Vamos criar mais um arch para que seja controlado pelo ansible: Vagrantfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end config . vm . define \"arch\" do | arch | main . vm . box = \"archlinux/archlinux\" end end Agora podemos dar up nessa nova m\u00e1quina: $ Execu\u00e7\u00e3o no terminal exit # caso esteja no conectado no main vagrant up arch Pegamos o endere\u00e7o de ip: $ Execu\u00e7\u00e3o no terminal vagrant ssh arch -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.16 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Adicionamos esse ip no invent\u00e1rio da m\u00e1quina controladora: /etc/ansible/hosts 1 2 3 4 5 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 Fazemos a troca de chaves SSH, para que o Controlador se comunique de forma segura com o arch : $ Execu\u00e7\u00e3o no terminal ssh-copy-id vagrant@10.0.2.16 # Para copiar a chave de `main` para `arch` Com isso temos dois grupos no n\u00f3 de controle. O ubuntu e o arch . Podemos criar um grupo novo tamb\u00e9m para juntar todos os linux e disparar comandos que funcionem nas duas m\u00e1quinas ao mesmo tempo: /etc/ansible/hosts 1 2 3 4 5 6 7 8 9 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 [linux] 10.0.2.15 10.0.2.16 Dessa forma, podemos chamar o m\u00f3dulo ping para todos os n\u00f3s em um grupo s\u00f3: $ Execu\u00e7\u00e3o no terminal ansible linux -m ping Caso tudo esteja configurado corretamente. Iremos obter sucesso em ambos os pings. O que significa que o comando foi executado com sucesso nas duas m\u00e1quinas. Instalando um pacote em dois n\u00f3s ao mesmo tempo Vamos iniciar uma configura\u00e7\u00e3o simples e que j\u00e1 rodamos no n\u00f3 controlador. Meu objetivo, por\u00e9m, \u00e9 mostrar a voc\u00eas o poder do ansible de forma simples: $ Execu\u00e7\u00e3o no terminal ansible linux -m package -a \"name=nginx state=present\" -b Dessa forma acabamos de instalar o servidor web Nginx nas nossas duas m\u00e1quinas virtuais ao mesmo tempo. Uma coisa importante de notar e que diferencia de uma forma simpl\u00f3ria de instala\u00e7\u00e3o. \u00c9 que n\u00e3o foi preciso dizer nem ao menos qual o gerenciador de pacotes que \u00e9 usado em cada distribui\u00e7\u00e3o. O m\u00f3dulo package entende isso por padr\u00e3o e usa o gerenciador da distribui\u00e7\u00e3o por baixo dos panos. Com isso, podemos conhecer outro m\u00f3dulo. O m\u00f3dulo do systemd e com ele podemos dizer que queremos dar start no processo do Nginx: $ Execu\u00e7\u00e3o no terminal ansible linux -m systemd -a \"name=nginx state=started\" -b E vol\u00e1, instalamos o Nginx em duas m\u00e1quinas e subimos o server somente usando comandos simples e sem a preocupa\u00e7\u00e3o de ter de entender coisas espec\u00edficas de sistema. Vamos ver se o servi\u00e7o subiu da forma correta? Para isso vou me aproveitar do ansible para instalar o httpie no sistema para fazer essa requisi\u00e7\u00e3o no n\u00f3 controlador. Por\u00e9m n\u00e3o quero fazer essa instala\u00e7\u00e3o sujando o ambiente. Ent\u00e3o, vamos instalar o pipx $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=python-pipx state=present\" -b Agora com o pipx instalado, podemos usar ele via m\u00f3dulo shell para instalar o httpie: $ Execu\u00e7\u00e3o no terminal ansible localhost -m shell -a \"pipx install httpie\" E agora, finalmente, podemos checar se ambos os servi\u00e7os foram startados corretamente pelo ansible: $ Execu\u00e7\u00e3o no terminal http 10 .0.2.15 http 10 .0.2.16 Embora tudo tenha sido executado de forma incr\u00edvel. Ainda considero chato de mais ficar chamando o ansible no terminal o tempo todo. Ent\u00e3o, precisamos de uma forma de melhorar isso.","title":"Entendendo a estrutura do ansible"},{"location":"04_configuracao_do_ansible/#entendendo-a-estrutura-do-ansible","text":"Embora at\u00e9 o momento executamos o ansible somente em uma m\u00e1quina local. E confesso que j\u00e1 pode ser bastante \u00fatil para padronizar suas configura\u00e7\u00f5es ap\u00f3s uma formata\u00e7\u00e3o, por exemplo. O Ansible brilha quando estamos falando de rede.","title":"Entendendo a estrutura do ansible"},{"location":"04_configuracao_do_ansible/#arquitetura-de-uso-do-ansible","text":"O Ansible distingue as m\u00e1quinas em duas categorias. O n\u00f3 de controle, onde o ansible est\u00e1 instalado e os n\u00f3s controlados. Que m\u00e1quinas em que o ansible pode se comunicar via SSH e executar os comandos: Dessa forma podemos partir do n\u00f3 de Controle e enviar rotinas de automa\u00e7\u00e3o para todos os n\u00f3s Controlados . Para isso o ansible conta com um arquivo de invent\u00e1rio. Um lugar onde todas as m\u00e1quinas que ser\u00e3o controladas pelo controlador devem ser registradas.","title":"Arquitetura de uso do ansible"},{"location":"04_configuracao_do_ansible/#arquivo-de-inventario","text":"Por padr\u00e3o o arquivo de invent\u00e1rio das m\u00e1quinas ficam no /etc/ansible/hosts . Vamos criar esse arquivo agora. $ Execu\u00e7\u00e3o no terminal # instala\u00e7\u00e3o do Nano, n\u00e3o vou obrigar ningu\u00e9m a usar o Emacs ;) ansible localhost -m package -a \"name=emacs state=present\" -b sudo nano /etc/ansible/hosts \u00c9 nesse arquivo que colocamos os endere\u00e7os dos n\u00f3s que ser\u00e3o controlados pelo ansible. O arquivo tem o seguinte formato: [<nome_do_grupo>] <endere\u00e7o_da_maquina> <op\u00e7\u00f5es> Por exemplo, vamos cadastrar nossa outra vm arch que ser\u00e1 controlado pelo main . Para isso, precisamos iniciar essa m\u00e1quina virtual. Antes disso, temos que sair do ssh em main : $ Execu\u00e7\u00e3o no terminal exit Agora voltamos a maquina principal. A m\u00e1quina onde as m\u00e1quinas virtuais foram instaladas. Vamos iniciar nossa outra m\u00e1quina. O ubuntu : vagrant up ubuntu Com isso, agora devemos ter duas m\u00e1quinas no nosso virtual box: [AA] - Mudar essa imagem Com nossa vm j\u00e1 de p\u00e9, podemos enviar um comando para o vagrant nos dizer o endere\u00e7o ip da m\u00e1quina ubuntu : $ Execu\u00e7\u00e3o no terminal vagrant ssh ubuntu -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.15 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Podemos ver que o IP associado a ubuntu \u00e9 10.0.2.15 . Que \u00e9 o endere\u00e7o que colocaremos no nosso invent\u00e1rio. Agora vamos voltar a nossa m\u00e1quina main via ssh: $ Execu\u00e7\u00e3o no terminal vagrant ssh main E vamos alterar nosso arquivo /etc/ansible/hosts dessa forma e com o comando sudo nano /etc/ansible/hosts : /etc/ansible/hosts 1 2 [ubuntu] 10.0.2.15 Dessa forma dissemos ao ansible que existe um grupo chamado ubuntu , uma dessas m\u00e1quinas tem o ip 10.0.2.15 . Assim, podemos enviar comandos para o grupo ubuntu .","title":"Arquivo de invent\u00e1rio"},{"location":"04_configuracao_do_ansible/#primeiro-comando-remoto","text":"E podemos checar enviando um ping para a vm ubuntu usando o seguinte comando ansible ubuntu -m ping : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m ping The authenticity of host '10.0.2.15 (10.0.2.15)' can 't be established. ED25519 key fingerprint is SHA256:FyOy2yTlOHSLJXVF+lmYjPywdfmQprApMWrsQ7KxUlI. This host key is known by the following other names/addresses: ~/.ssh/known_hosts:1: localhost Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 10.0.2.15 | UNREACHABLE! => { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: Warning: Permanently added ' 10 .0.2.15 ' ( ED25519 ) to the list of known hosts. \\r\\n vagrant@10.0.2.15: Permission denied ( publickey,password ) . \", \" unreachable \": true } Um erro ocorreu por conta da seguran\u00e7a. O SSH da vm ubuntu n\u00e3o permitiu que o ansible fizesse a conex\u00e3o. Para isso precisamos trocar chaves entre os hosts para que aconte\u00e7a de maneira segura.","title":"Primeiro comando remoto"},{"location":"04_configuracao_do_ansible/#troca-de-chaves-ssh","text":"Vamos voltar ao shell e digitar os seguintes comandos: $ Execu\u00e7\u00e3o no terminal ssh-keygen # para gerar uma chave ssh para nossa vm `main` ssh-copy-id vagrant@10.0.2.15 # Para copiar a chave de `main` para `ubuntu` Se executarmos o ping novamente obteremos sucesso: $ Execu\u00e7\u00e3o no terminal ansible arch -m ping 10 .0.2.15 | SUCCESS = > { \"ansible_facts\" : { \"discovered_interpreter_python\" : \"/usr/bin/python3.10\" } , \"changed\" : false, \"ping\" : \"pong\" } Isso significa que a comunica\u00e7\u00e3o com os dois n\u00f3s est\u00e1 acontecendo de maneira correta. Mas, faltou entender o que o comando ansible ubuntu -m ping significa: ansible: Chama o ansible ubuntu: O nome do grupo do invent\u00e1rio -m: Significa que vamos chamar um m\u00f3dulo ping: M\u00f3dulo para checar se o grupo est\u00e1 respondendo","title":"Troca de chaves SSH"},{"location":"04_configuracao_do_ansible/#repetindo-o-processo-para-mais-uma-maquina","text":"Agora que j\u00e1 entendemos o que temos que fazer. Podemos adicionar mais uma m\u00e1quina virtual ao nosso ambiente. Vamos criar mais um arch para que seja controlado pelo ansible: Vagrantfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end config . vm . define \"arch\" do | arch | main . vm . box = \"archlinux/archlinux\" end end Agora podemos dar up nessa nova m\u00e1quina: $ Execu\u00e7\u00e3o no terminal exit # caso esteja no conectado no main vagrant up arch Pegamos o endere\u00e7o de ip: $ Execu\u00e7\u00e3o no terminal vagrant ssh arch -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.16 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Adicionamos esse ip no invent\u00e1rio da m\u00e1quina controladora: /etc/ansible/hosts 1 2 3 4 5 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 Fazemos a troca de chaves SSH, para que o Controlador se comunique de forma segura com o arch : $ Execu\u00e7\u00e3o no terminal ssh-copy-id vagrant@10.0.2.16 # Para copiar a chave de `main` para `arch` Com isso temos dois grupos no n\u00f3 de controle. O ubuntu e o arch . Podemos criar um grupo novo tamb\u00e9m para juntar todos os linux e disparar comandos que funcionem nas duas m\u00e1quinas ao mesmo tempo: /etc/ansible/hosts 1 2 3 4 5 6 7 8 9 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 [linux] 10.0.2.15 10.0.2.16 Dessa forma, podemos chamar o m\u00f3dulo ping para todos os n\u00f3s em um grupo s\u00f3: $ Execu\u00e7\u00e3o no terminal ansible linux -m ping Caso tudo esteja configurado corretamente. Iremos obter sucesso em ambos os pings. O que significa que o comando foi executado com sucesso nas duas m\u00e1quinas.","title":"Repetindo o processo para mais uma m\u00e1quina"},{"location":"04_configuracao_do_ansible/#instalando-um-pacote-em-dois-nos-ao-mesmo-tempo","text":"Vamos iniciar uma configura\u00e7\u00e3o simples e que j\u00e1 rodamos no n\u00f3 controlador. Meu objetivo, por\u00e9m, \u00e9 mostrar a voc\u00eas o poder do ansible de forma simples: $ Execu\u00e7\u00e3o no terminal ansible linux -m package -a \"name=nginx state=present\" -b Dessa forma acabamos de instalar o servidor web Nginx nas nossas duas m\u00e1quinas virtuais ao mesmo tempo. Uma coisa importante de notar e que diferencia de uma forma simpl\u00f3ria de instala\u00e7\u00e3o. \u00c9 que n\u00e3o foi preciso dizer nem ao menos qual o gerenciador de pacotes que \u00e9 usado em cada distribui\u00e7\u00e3o. O m\u00f3dulo package entende isso por padr\u00e3o e usa o gerenciador da distribui\u00e7\u00e3o por baixo dos panos. Com isso, podemos conhecer outro m\u00f3dulo. O m\u00f3dulo do systemd e com ele podemos dizer que queremos dar start no processo do Nginx: $ Execu\u00e7\u00e3o no terminal ansible linux -m systemd -a \"name=nginx state=started\" -b E vol\u00e1, instalamos o Nginx em duas m\u00e1quinas e subimos o server somente usando comandos simples e sem a preocupa\u00e7\u00e3o de ter de entender coisas espec\u00edficas de sistema. Vamos ver se o servi\u00e7o subiu da forma correta? Para isso vou me aproveitar do ansible para instalar o httpie no sistema para fazer essa requisi\u00e7\u00e3o no n\u00f3 controlador. Por\u00e9m n\u00e3o quero fazer essa instala\u00e7\u00e3o sujando o ambiente. Ent\u00e3o, vamos instalar o pipx $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=python-pipx state=present\" -b Agora com o pipx instalado, podemos usar ele via m\u00f3dulo shell para instalar o httpie: $ Execu\u00e7\u00e3o no terminal ansible localhost -m shell -a \"pipx install httpie\" E agora, finalmente, podemos checar se ambos os servi\u00e7os foram startados corretamente pelo ansible: $ Execu\u00e7\u00e3o no terminal http 10 .0.2.15 http 10 .0.2.16 Embora tudo tenha sido executado de forma incr\u00edvel. Ainda considero chato de mais ficar chamando o ansible no terminal o tempo todo. Ent\u00e3o, precisamos de uma forma de melhorar isso.","title":"Instalando um pacote em dois n\u00f3s ao mesmo tempo"},{"location":"05_playbooks/","text":"Playbooks Tudo que executamos at\u00e9 agora foram comandos no terminal com ansible. Voc\u00ea deve estar se perguntando se n\u00e3o seria mais f\u00e1cil criar um script com todos esses comandos, para evitar ter que digitar todas as vezes. Para isso existem os playbooks. Voc\u00ea cria um arquivo no formato yaml descrevendo todas as suas tarefas e executa de uma \u00fanica vez. O nome Playbook Playbook \u00e9 uma palavra que se refere a scripts de teatro. Por exemplo, quando algu\u00e9m entra em cena, as falas de cada personagem e etc... No mundo dos esportes playbook \u00e9 usado muito no baseball e no basket. S\u00e3o listas de jogadas que podem ser feitas durante um jogo. Arquivos YAML Arquivos YAML s\u00e3o arquivos geralmente usados para configura\u00e7\u00f5es. Se pensarmos em Python, eles formam estruturas equivalentes a de dicion\u00e1rios. Uma compara\u00e7\u00e3o b\u00e1sica para voc\u00ea entender o formato: YAML Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- chave : valor # valor \u00e9 uma string chave_int : 1 # valor \u00e9 uma int chave_bool : true # valor \u00e9 uma bool uma_lista : - item_0 - item_1 - item_2 um_dict : nome : eduardo idade : 29 # Coment\u00e1rios lista_inline : [ 'item_0' , 'item_1' , 'item_2' ] dict_inline : { 'nome' : 'eduardo' , 'idade' : 29 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"chave\" : \"valor\" , \"chave_int\" : 1 , \"chave_bool\" : true , \"uma_lista\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"um_dict\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 }, \"lista_inline\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"dict_inline\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 } } Nosso primeiro playbook Vamos reproduzir a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Ngix que fizemos via comandos ad-hoc no terminal: web_server.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- - name : Instala\u00e7\u00e3o do nginx hosts : linux # Grupo de hosts do invent\u00e1rio become : yes # Diz que vai escalonar privil\u00e9gios. Equivalente ao -b tasks : # Descri\u00e7\u00e3o das tarefas que ser\u00e3o executadas - name : Instala\u00e7\u00e3o do nginx # Nome da tarefa package : # Nome do m\u00f3dulo # Argumentos do m\u00f3dulo state : present name : nginx - name : Inicializa\u00e7\u00e3o do nginx systemd : state : started name : nginx Dessa forma, no lugar de executar um \u00fanico comando por vez, podemos disparar um playbook que executa diversas tarefas por vez: $ Execu\u00e7\u00e3o no terminal ansible-playbook web_server.yml Voc\u00ea deve ver uma grande resposta como essa: resposta do terminal ansible-playbook web_server.yml PLAY [ Instala\u00e7\u00e3o do nginx ] ***************************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do nginx ] ***************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Inicializa\u00e7\u00e3o do nginx ] ************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ********************************************************************* 10 .0.2.15 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.16 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O que significa que o ansible conseguiu executar o playbook com sucesso. Mais um playbook Sei que voc\u00ea j\u00e1 deve ter captado a ideia do playbook, mas que tal criarmos mais um? Vamos tentar reproduzir a configura\u00e7\u00e3o do emacs no localhost agora. Pois temos outros m\u00f3dulos e outros comandos para aprender: emacs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- - name : Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs hosts : localhost # Aqui mudamos para o localhost tasks : - name : Instala\u00e7\u00e3o do emacs become : yes # Diferente da outra config, somente esse passo ser\u00e1 como root package : state : present name : emacs - name : Instala\u00e7\u00e3o do git become : yes package : name : git state : present - name : Clone do nosso reposit\u00f3rio git : repo : https://github.com/dunossauro/dotfiles.git dest : config_files - name : Movendo os arquivos de configura\u00e7\u00e3o do emacs copy : dest : /home/vagrant/ src : /home/vagrant/config_files/.emacs.d Se executarmos esse playbook podemos ver algumas mensagens diferentes na resposta: $ Execu\u00e7\u00e3o no terminal ansible-playbook emacs.yml A resposta: resposta do terminal PLAY [ Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs ] ************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do emacs ] ***************************************************** ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do git ] ******************************************************* ok: [ localhost ] TASK [ Clone do nosso reposit\u00f3rio ] ********************************************** changed : [ localhost ] TASK [ Movendo os arquivos de configura\u00e7\u00e3o do emacs ] **************************** changed : [ localhost ] PLAY RECAP ********************************************************************* localhost : ok = 5 changed = 2 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O status changed apareceu. Significa que o resultado desse comando foi diferente da primeira vez que foi executado. O que quer dizer que alguma coisa mudou desde a ultima execu\u00e7\u00e3o. Provavelmente a resposta do ansible foi diferente pois o clone n\u00e3o foi feito, o diret\u00f3rio j\u00e1 existia e o move tamb\u00e9m j\u00e1 tinha sido feito antes. Condicionais Vamos recapitular mais uma coisa que j\u00e1 instalamos no nosso ambiente. O pipx e o httpie . N\u00e3o s\u00e3o pacotes t\u00e3o relevantes para o andamento do tutorial, mas precisamos aprender coisas legais com ansible antes de fazer coisas realmente \u00fateis. O pacote do pipx existe no reposit\u00f3rio do archlinux como j\u00e1 vimos. O pacote se chama python-pipx . Vamos iniciar um playbook para essa instala\u00e7\u00e3o e ver os problemas que vamos encontrar no caminho: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux # vale lembrar aqui que um dos linux \u00e9 o arch e o outro o ubuntu tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : python-pipx state : present Vamos executar para ver o que conseguimos com isso: $ Execu\u00e7\u00e3o no terminal ansible-playbook pipx_httpie.yml Obteremos a seguinte resposta: PLAY [Instala\u00e7\u00e3o do pipx e httpie] ********************************************* TASK [Gathering Facts] ********************************************************* ok: [10.0.2.15] ok: [10.0.2.16] TASK [Instala\u00e7\u00e3o do pipx] ****************************************************** fatal: [10.0.2.15]: FAILED! => {\"changed\": false, \"msg\": \"No package matching 'python-pipx' is available\"} changed: [10.0.2.16] PLAY RECAP ********************************************************************* 10.0.2.15 : ok=1 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0 10.0.2.16 : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 Repare na linha destacada. A m\u00e1quina associada ao ip 10.2.2.15 n\u00e3o tem um pacote no reposit\u00f3rio chamado python-pipx . Esse foi o motivo da falha. O pacote existe no reposit\u00f3rio do arch, por\u00e9m n\u00e3o existe no reposit\u00f3rio do ubuntu. Para resolver esse problema precisamos descobrir o nome do pacote no reposit\u00f3rio do ubuntu . E para saber isso precisamos saber qual a vers\u00e3o do ubuntu estamos usando. Voc\u00ea deve se lembrar que escrever no Vagrantfile ubuntu/focal64 . Ent\u00e3o, sabemos que a vers\u00e3o \u00e9 a focal . Por\u00e9m, se n\u00e3o soub\u00e9ssemos essa informa\u00e7\u00e3o. Como o ansible poderia nos ajudar a descobrir? O m\u00f3dulo setup O Ansible conta com um m\u00f3dulo chamado setup . Esse m\u00f3dulo pode ser chamado via ad-hoc, mas tamb\u00e9m \u00e9 a base para algumas vari\u00e1veis nos playbooks. Primeiro vamos executar via ad-hoc: $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m setup Esse comando nos retornar\u00e1 uma resposta MUITO extensa. Que acabei deixando em um arquivo separado. Voc\u00ea pode acessar aqui . Vamos destacar somente algumas coisas que fazem sentido para nosso passo atual: 344 345 346 347 348 349 350 \"ansible_distribution\" : \"Ubuntu\" , \"ansible_distribution_file_parsed\" : true , \"ansible_distribution_file_path\" : \"/etc/os-release\" , \"ansible_distribution_file_variety\" : \"Debian\" , \"ansible_distribution_major_version\" : \"20\" , \"ansible_distribution_release\" : \"focal\" , \"ansible_distribution_version\" : \"20.04\" , Podemos ver que o ansible sabe qual a distribui\u00e7\u00e3o que est\u00e1 sendo usada Ubuntu , qual a vers\u00e3o do sistema 20.04 e a release que est\u00e1 sendo executada focal . O setup consegue mostrar diversos outros dados. Sobre as interfaces de rede, sobre mem\u00f3ria e etc... Aproveitando que j\u00e1 estamos vendo o m\u00f3dulo setup , podemos usar a fun\u00e7\u00e3o de filtro do m\u00f3dulo para exibir somente as informa\u00e7\u00f5es que precisamos. Qualquer coisa que comece com ansible_distribution : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m setup -a \"filter=ansible_distribution*\" Que nos retornar\u00e1 os mesmos dados que destaquei: 10.0.2.15 | SUCCESS => { \"ansible_facts\": { \"ansible_distribution\": \"Ubuntu\", \"ansible_distribution_file_parsed\": true, \"ansible_distribution_file_path\": \"/etc/os-release\", \"ansible_distribution_file_variety\": \"Debian\", \"ansible_distribution_major_version\": \"20\", \"ansible_distribution_release\": \"focal\", \"ansible_distribution_version\": \"20.04\", \"discovered_interpreter_python\": \"/usr/bin/python3\" }, \"changed\": false } Agora que sabemos que \u00e9 o Ubuntu Focal, podemos voltar ao reposit\u00f3rio. O pacote existe, por\u00e9m, com outro nome pipx . A clausula when Como disse, as vari\u00e1veis do setup podem ser invocadas dentro do playbook. Dessa forma podemos criar valida\u00e7\u00f5es condicionais no nosso playbook. Vamos criar uma restri\u00e7\u00e3o para que a task seja executada somente no arch linux: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 11 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux # vale lembrar aqui que um dos linux \u00e9 o arch e o outro o ubuntu tasks : - name : Instala\u00e7\u00e3o do pipx no Arch become : yes package : name : python-pipx state : present when : ansible_distribution == Archlinux' As linhas destacadas mostra somente as altera\u00e7\u00f5es que fizemos no playbook. Dessa forma, a task Instala\u00e7\u00e3o do pipx no Arch s\u00f3 ser\u00e1 executada quando a distribui\u00e7\u00e3o for Archlinux . Vamos testar: $ Execu\u00e7\u00e3o no terminal ansible-playbook pipx_httpie.yml Resultado do shell PLAY [ Instala\u00e7\u00e3o do pipx e httpie ] ******************************************************** TASK [ Gathering Facts ] ******************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* skipping: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ******************************************************************************** 10 .0.2.16 : ok = 2 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.15 : ok = 1 changed = 0 unreachable = 0 failed = 0 skipped = 1 rescued = 0 ignored = 0 Com isso, podemos ver o status skipped . Isso quer dizer que o passo de instalar no arch, quando passou pela instala\u00e7\u00e3o no ubuntu \"pulou\" esse passo. Sabendo disso, podemos criar uma nova task espec\u00edfica para o ubuntu que pule no arch tamb\u00e9m: pipx_httpie.yml 13 14 15 16 17 18 - name : Instala\u00e7\u00e3o do pipx no Ubuntu become : yes package : name : pipx state : present when : ansible_distribution == 'Ubuntu' Dessa forma, quando executarmos o playbook teremos certeza que a execu\u00e7\u00e3o vai acontecer nos dois n\u00f3s. Mesmo que em tasks diferentes. $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* skipping: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do pipx no Ubuntu ] ******************************************************* skipping: [ 10 .0.2.16 ] ok: [ 10 .0.2.15 ] Desta forma n\u00e3o precisamos mais nos preocupar com os pacotes espec\u00edficos de cada sistema, podemos criar uma task para cada sistema. Em casos extremos isso pode ser necess\u00e1rio. Mas ser\u00e1 que n\u00e3o existe uma forma mais simples de resolver esse problema? Express\u00f5es e vari\u00e1veis Quando chamamos o setup, vimos que o ansible consegue carregar diversas vari\u00e1veis durante a execu\u00e7\u00e3o. Mas ser\u00e1 que nesse caso n\u00e3o conseguir\u00edamos criar uma vari\u00e1vel nossa? A\u00ed poder\u00edamos validar antes e evitar de escrever duas tasks. Express\u00f5es O Ansible usa um motor de templates chamado Jinja . O jinja fornece uma forma de chamar express\u00f5es de c\u00f3digo Python dentro de templates. Assim, quando o ansible executa um playbook ele tamb\u00e9m avalia e executa as express\u00f5es do jinja dentro do c\u00f3digo. As express\u00f5es no jinja s\u00e3o feitas usando duas chaves delimitador {{ minha_express\u00e3o }} . E dentre dessa express\u00e3o, qualquer c\u00f3digo python pode ser inserido. Por exemplo, podemos fazer um if para resolver nosso caso e ter uma \u00fanica task. Por exemplo: pipx_httpie.yml 5 6 7 8 9 10 tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" state : present Nota sobre express\u00f5es no Asnbile Embora para o jinja somente precise ser usado {{ express\u00e3o }} . O Ansible exige que esses blocos estejam tamb\u00e9m entre aspas. Ficando '{{ express\u00e3o }}' . Desta forma acabamos resolvendo o problema que t\u00ednhamos em ter duas tasks para executar a mesma tarefa em sistemas diferentes. Vamos ver o resultado: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] Assim podemos ser mais eficientes em criar regras. J\u00e1 o que template pode estender c\u00f3digo python. As vari\u00e1veis no ansible Da mesma forma que podemos criar express\u00f5es complexas no jinja. Tamb\u00e9m podemos chamar somente vari\u00e1veis. Por exemplo \"{{ variavel }}\" . Assim podemos declarar as express\u00f5es em um lugar espec\u00edfico do playbook para deixar mais limpo ou passar as mesmas via linha de comando. Vari\u00e1veis no playbook Para isso, podemos trocar o nome do pacote do pipx no playbook para uma vari\u00e1vel: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux vars : pipx : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : '{{ pipx }}' state : present Assim temos um playbook mais limpo. Pois todo o c\u00f3digo complicado do jinja fica em um lugar espec\u00edfico e no topo do arquivo para ficar f\u00e1cil a consulta. N\u00e3o vou executar esse playbook agora, pois teremos o mesmo resultado da execu\u00e7\u00e3o anterior. Vari\u00e1veis via linha de comando Outra funcionalidade importante do ansible \u00e9 conseguir sobrescrever as vari\u00e1veis de um playbook usando a linha de comando como base. Chamar via linha de comando tem uma ordem de preced\u00eancia maior que as vari\u00e1veis definidas no playbook. Ent\u00e3o, quando o ansible for chamado as vari\u00e1veis definidas no campo vars ser\u00e3o substitu\u00eddas pelas vari\u00e1veis que forem passadas na linha de comando: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml --extra-vars \"pipx=pipx\" TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] fatal: [ 10 .0.2.16 ] : FAILED! = > { \"changed\" : false, \"cmd\" : [ \"/usr/bin/pacman\" , \"--upgrade\" , \"--print-format\" , \"%n\" , \"pipx\" ] , \"msg\" : \"Failed to list package pipx\" , \"rc\" : 1 , \"stderr\" : \"error: 'pipx': could not find or read package\\n\" , \"stderr_lines\" : [ \"error: 'pipx': could not find or read package\" ] , \"stdout\" : \"loading packages...\\n\" , \"stdout_lines\" : [ \"loading packages...\" ]} Como era de se esperar, o pacote pipx n\u00e3o existe no arch, seu nome \u00e9 python-pipx por conta disso, o comando n\u00e3o foi executado com sucesso. Nosso objetivo, por\u00e9m, era explorar a chamada de vari\u00e1veis via linha de comando. Arquivos de vari\u00e1veis Uma forma de evitar express\u00f5es do jinja e tamb\u00e9m chamar vari\u00e1veis por linha de comando \u00e9 criar um arquivo s\u00f3 para as vari\u00e1veis. Dessa forma, caso tenha alguma vari\u00e1vel que n\u00e3o possa ser exposta, como endere\u00e7o de um banco de dados. Esse valores ficam de fora da configura\u00e7\u00e3o. variaveis.yml 1 2 --- pipx : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" Dessa forma podemos limpar o nosso arquivo pipx_httpie.yml : pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : '{{ pipx }}' state : present E quando formos executar o playbook, s\u00f3 precisamos passar o arquivo de configura\u00e7\u00e3o para as vari\u00e1veis: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml -e @variaveis.yml TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] Assim demos uma limpada no nosso arquivo de playbook e claro, podemos definir diversas outras vari\u00e1veis no arquivo. Mas, voc\u00ea pode tentar depois Arquivos de vari\u00e1veis por grupo Uma outra coisa que pode facilitar na hora de usar as vari\u00e1veis \u00e9 criar vari\u00e1veis espec\u00edficas para grupos. O ansible tem um caminho espec\u00edfico para onde esses arquivos de vari\u00e1veis devem ser colocados: /etc/ansible/group_vars/ . Para resolver isso, vamos criar um grupo de vari\u00e1veis para o ubuntu: /etc/ansible/group_vars/ubuntu.yml 1 2 --- pipx : pipx e um arquivo para o arch: /etc/ansible/group_vars/arch.yml 1 2 --- pipx : python-pipx Dessa forma, quando formos executar o playbook n\u00e3o precisamos mais especificar as vari\u00e1veis comuns. Cada sistema tem sua vers\u00e3o de pipx de acordo com os grupos do invent\u00e1rio: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ]","title":"Playbooks"},{"location":"05_playbooks/#playbooks","text":"Tudo que executamos at\u00e9 agora foram comandos no terminal com ansible. Voc\u00ea deve estar se perguntando se n\u00e3o seria mais f\u00e1cil criar um script com todos esses comandos, para evitar ter que digitar todas as vezes. Para isso existem os playbooks. Voc\u00ea cria um arquivo no formato yaml descrevendo todas as suas tarefas e executa de uma \u00fanica vez. O nome Playbook Playbook \u00e9 uma palavra que se refere a scripts de teatro. Por exemplo, quando algu\u00e9m entra em cena, as falas de cada personagem e etc... No mundo dos esportes playbook \u00e9 usado muito no baseball e no basket. S\u00e3o listas de jogadas que podem ser feitas durante um jogo.","title":"Playbooks"},{"location":"05_playbooks/#arquivos-yaml","text":"Arquivos YAML s\u00e3o arquivos geralmente usados para configura\u00e7\u00f5es. Se pensarmos em Python, eles formam estruturas equivalentes a de dicion\u00e1rios. Uma compara\u00e7\u00e3o b\u00e1sica para voc\u00ea entender o formato: YAML Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- chave : valor # valor \u00e9 uma string chave_int : 1 # valor \u00e9 uma int chave_bool : true # valor \u00e9 uma bool uma_lista : - item_0 - item_1 - item_2 um_dict : nome : eduardo idade : 29 # Coment\u00e1rios lista_inline : [ 'item_0' , 'item_1' , 'item_2' ] dict_inline : { 'nome' : 'eduardo' , 'idade' : 29 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"chave\" : \"valor\" , \"chave_int\" : 1 , \"chave_bool\" : true , \"uma_lista\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"um_dict\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 }, \"lista_inline\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"dict_inline\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 } }","title":"Arquivos YAML"},{"location":"05_playbooks/#nosso-primeiro-playbook","text":"Vamos reproduzir a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Ngix que fizemos via comandos ad-hoc no terminal: web_server.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- - name : Instala\u00e7\u00e3o do nginx hosts : linux # Grupo de hosts do invent\u00e1rio become : yes # Diz que vai escalonar privil\u00e9gios. Equivalente ao -b tasks : # Descri\u00e7\u00e3o das tarefas que ser\u00e3o executadas - name : Instala\u00e7\u00e3o do nginx # Nome da tarefa package : # Nome do m\u00f3dulo # Argumentos do m\u00f3dulo state : present name : nginx - name : Inicializa\u00e7\u00e3o do nginx systemd : state : started name : nginx Dessa forma, no lugar de executar um \u00fanico comando por vez, podemos disparar um playbook que executa diversas tarefas por vez: $ Execu\u00e7\u00e3o no terminal ansible-playbook web_server.yml Voc\u00ea deve ver uma grande resposta como essa: resposta do terminal ansible-playbook web_server.yml PLAY [ Instala\u00e7\u00e3o do nginx ] ***************************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do nginx ] ***************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Inicializa\u00e7\u00e3o do nginx ] ************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ********************************************************************* 10 .0.2.15 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.16 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O que significa que o ansible conseguiu executar o playbook com sucesso.","title":"Nosso primeiro playbook"},{"location":"05_playbooks/#mais-um-playbook","text":"Sei que voc\u00ea j\u00e1 deve ter captado a ideia do playbook, mas que tal criarmos mais um? Vamos tentar reproduzir a configura\u00e7\u00e3o do emacs no localhost agora. Pois temos outros m\u00f3dulos e outros comandos para aprender: emacs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- - name : Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs hosts : localhost # Aqui mudamos para o localhost tasks : - name : Instala\u00e7\u00e3o do emacs become : yes # Diferente da outra config, somente esse passo ser\u00e1 como root package : state : present name : emacs - name : Instala\u00e7\u00e3o do git become : yes package : name : git state : present - name : Clone do nosso reposit\u00f3rio git : repo : https://github.com/dunossauro/dotfiles.git dest : config_files - name : Movendo os arquivos de configura\u00e7\u00e3o do emacs copy : dest : /home/vagrant/ src : /home/vagrant/config_files/.emacs.d Se executarmos esse playbook podemos ver algumas mensagens diferentes na resposta: $ Execu\u00e7\u00e3o no terminal ansible-playbook emacs.yml A resposta: resposta do terminal PLAY [ Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs ] ************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do emacs ] ***************************************************** ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do git ] ******************************************************* ok: [ localhost ] TASK [ Clone do nosso reposit\u00f3rio ] ********************************************** changed : [ localhost ] TASK [ Movendo os arquivos de configura\u00e7\u00e3o do emacs ] **************************** changed : [ localhost ] PLAY RECAP ********************************************************************* localhost : ok = 5 changed = 2 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O status changed apareceu. Significa que o resultado desse comando foi diferente da primeira vez que foi executado. O que quer dizer que alguma coisa mudou desde a ultima execu\u00e7\u00e3o. Provavelmente a resposta do ansible foi diferente pois o clone n\u00e3o foi feito, o diret\u00f3rio j\u00e1 existia e o move tamb\u00e9m j\u00e1 tinha sido feito antes.","title":"Mais um playbook"},{"location":"05_playbooks/#condicionais","text":"Vamos recapitular mais uma coisa que j\u00e1 instalamos no nosso ambiente. O pipx e o httpie . N\u00e3o s\u00e3o pacotes t\u00e3o relevantes para o andamento do tutorial, mas precisamos aprender coisas legais com ansible antes de fazer coisas realmente \u00fateis. O pacote do pipx existe no reposit\u00f3rio do archlinux como j\u00e1 vimos. O pacote se chama python-pipx . Vamos iniciar um playbook para essa instala\u00e7\u00e3o e ver os problemas que vamos encontrar no caminho: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux # vale lembrar aqui que um dos linux \u00e9 o arch e o outro o ubuntu tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : python-pipx state : present Vamos executar para ver o que conseguimos com isso: $ Execu\u00e7\u00e3o no terminal ansible-playbook pipx_httpie.yml Obteremos a seguinte resposta: PLAY [Instala\u00e7\u00e3o do pipx e httpie] ********************************************* TASK [Gathering Facts] ********************************************************* ok: [10.0.2.15] ok: [10.0.2.16] TASK [Instala\u00e7\u00e3o do pipx] ****************************************************** fatal: [10.0.2.15]: FAILED! => {\"changed\": false, \"msg\": \"No package matching 'python-pipx' is available\"} changed: [10.0.2.16] PLAY RECAP ********************************************************************* 10.0.2.15 : ok=1 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0 10.0.2.16 : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 Repare na linha destacada. A m\u00e1quina associada ao ip 10.2.2.15 n\u00e3o tem um pacote no reposit\u00f3rio chamado python-pipx . Esse foi o motivo da falha. O pacote existe no reposit\u00f3rio do arch, por\u00e9m n\u00e3o existe no reposit\u00f3rio do ubuntu. Para resolver esse problema precisamos descobrir o nome do pacote no reposit\u00f3rio do ubuntu . E para saber isso precisamos saber qual a vers\u00e3o do ubuntu estamos usando. Voc\u00ea deve se lembrar que escrever no Vagrantfile ubuntu/focal64 . Ent\u00e3o, sabemos que a vers\u00e3o \u00e9 a focal . Por\u00e9m, se n\u00e3o soub\u00e9ssemos essa informa\u00e7\u00e3o. Como o ansible poderia nos ajudar a descobrir?","title":"Condicionais"},{"location":"05_playbooks/#o-modulo-setup","text":"O Ansible conta com um m\u00f3dulo chamado setup . Esse m\u00f3dulo pode ser chamado via ad-hoc, mas tamb\u00e9m \u00e9 a base para algumas vari\u00e1veis nos playbooks. Primeiro vamos executar via ad-hoc: $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m setup Esse comando nos retornar\u00e1 uma resposta MUITO extensa. Que acabei deixando em um arquivo separado. Voc\u00ea pode acessar aqui . Vamos destacar somente algumas coisas que fazem sentido para nosso passo atual: 344 345 346 347 348 349 350 \"ansible_distribution\" : \"Ubuntu\" , \"ansible_distribution_file_parsed\" : true , \"ansible_distribution_file_path\" : \"/etc/os-release\" , \"ansible_distribution_file_variety\" : \"Debian\" , \"ansible_distribution_major_version\" : \"20\" , \"ansible_distribution_release\" : \"focal\" , \"ansible_distribution_version\" : \"20.04\" , Podemos ver que o ansible sabe qual a distribui\u00e7\u00e3o que est\u00e1 sendo usada Ubuntu , qual a vers\u00e3o do sistema 20.04 e a release que est\u00e1 sendo executada focal . O setup consegue mostrar diversos outros dados. Sobre as interfaces de rede, sobre mem\u00f3ria e etc... Aproveitando que j\u00e1 estamos vendo o m\u00f3dulo setup , podemos usar a fun\u00e7\u00e3o de filtro do m\u00f3dulo para exibir somente as informa\u00e7\u00f5es que precisamos. Qualquer coisa que comece com ansible_distribution : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m setup -a \"filter=ansible_distribution*\" Que nos retornar\u00e1 os mesmos dados que destaquei: 10.0.2.15 | SUCCESS => { \"ansible_facts\": { \"ansible_distribution\": \"Ubuntu\", \"ansible_distribution_file_parsed\": true, \"ansible_distribution_file_path\": \"/etc/os-release\", \"ansible_distribution_file_variety\": \"Debian\", \"ansible_distribution_major_version\": \"20\", \"ansible_distribution_release\": \"focal\", \"ansible_distribution_version\": \"20.04\", \"discovered_interpreter_python\": \"/usr/bin/python3\" }, \"changed\": false } Agora que sabemos que \u00e9 o Ubuntu Focal, podemos voltar ao reposit\u00f3rio. O pacote existe, por\u00e9m, com outro nome pipx .","title":"O m\u00f3dulo setup"},{"location":"05_playbooks/#a-clausula-when","text":"Como disse, as vari\u00e1veis do setup podem ser invocadas dentro do playbook. Dessa forma podemos criar valida\u00e7\u00f5es condicionais no nosso playbook. Vamos criar uma restri\u00e7\u00e3o para que a task seja executada somente no arch linux: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 11 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux # vale lembrar aqui que um dos linux \u00e9 o arch e o outro o ubuntu tasks : - name : Instala\u00e7\u00e3o do pipx no Arch become : yes package : name : python-pipx state : present when : ansible_distribution == Archlinux' As linhas destacadas mostra somente as altera\u00e7\u00f5es que fizemos no playbook. Dessa forma, a task Instala\u00e7\u00e3o do pipx no Arch s\u00f3 ser\u00e1 executada quando a distribui\u00e7\u00e3o for Archlinux . Vamos testar: $ Execu\u00e7\u00e3o no terminal ansible-playbook pipx_httpie.yml Resultado do shell PLAY [ Instala\u00e7\u00e3o do pipx e httpie ] ******************************************************** TASK [ Gathering Facts ] ******************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* skipping: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ******************************************************************************** 10 .0.2.16 : ok = 2 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.15 : ok = 1 changed = 0 unreachable = 0 failed = 0 skipped = 1 rescued = 0 ignored = 0 Com isso, podemos ver o status skipped . Isso quer dizer que o passo de instalar no arch, quando passou pela instala\u00e7\u00e3o no ubuntu \"pulou\" esse passo. Sabendo disso, podemos criar uma nova task espec\u00edfica para o ubuntu que pule no arch tamb\u00e9m: pipx_httpie.yml 13 14 15 16 17 18 - name : Instala\u00e7\u00e3o do pipx no Ubuntu become : yes package : name : pipx state : present when : ansible_distribution == 'Ubuntu' Dessa forma, quando executarmos o playbook teremos certeza que a execu\u00e7\u00e3o vai acontecer nos dois n\u00f3s. Mesmo que em tasks diferentes. $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* skipping: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do pipx no Ubuntu ] ******************************************************* skipping: [ 10 .0.2.16 ] ok: [ 10 .0.2.15 ] Desta forma n\u00e3o precisamos mais nos preocupar com os pacotes espec\u00edficos de cada sistema, podemos criar uma task para cada sistema. Em casos extremos isso pode ser necess\u00e1rio. Mas ser\u00e1 que n\u00e3o existe uma forma mais simples de resolver esse problema?","title":"A clausula when"},{"location":"05_playbooks/#expressoes-e-variaveis","text":"Quando chamamos o setup, vimos que o ansible consegue carregar diversas vari\u00e1veis durante a execu\u00e7\u00e3o. Mas ser\u00e1 que nesse caso n\u00e3o conseguir\u00edamos criar uma vari\u00e1vel nossa? A\u00ed poder\u00edamos validar antes e evitar de escrever duas tasks.","title":"Express\u00f5es e vari\u00e1veis"},{"location":"05_playbooks/#expressoes","text":"O Ansible usa um motor de templates chamado Jinja . O jinja fornece uma forma de chamar express\u00f5es de c\u00f3digo Python dentro de templates. Assim, quando o ansible executa um playbook ele tamb\u00e9m avalia e executa as express\u00f5es do jinja dentro do c\u00f3digo. As express\u00f5es no jinja s\u00e3o feitas usando duas chaves delimitador {{ minha_express\u00e3o }} . E dentre dessa express\u00e3o, qualquer c\u00f3digo python pode ser inserido. Por exemplo, podemos fazer um if para resolver nosso caso e ter uma \u00fanica task. Por exemplo: pipx_httpie.yml 5 6 7 8 9 10 tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" state : present Nota sobre express\u00f5es no Asnbile Embora para o jinja somente precise ser usado {{ express\u00e3o }} . O Ansible exige que esses blocos estejam tamb\u00e9m entre aspas. Ficando '{{ express\u00e3o }}' . Desta forma acabamos resolvendo o problema que t\u00ednhamos em ter duas tasks para executar a mesma tarefa em sistemas diferentes. Vamos ver o resultado: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] Assim podemos ser mais eficientes em criar regras. J\u00e1 o que template pode estender c\u00f3digo python.","title":"Express\u00f5es"},{"location":"05_playbooks/#as-variaveis-no-ansible","text":"Da mesma forma que podemos criar express\u00f5es complexas no jinja. Tamb\u00e9m podemos chamar somente vari\u00e1veis. Por exemplo \"{{ variavel }}\" . Assim podemos declarar as express\u00f5es em um lugar espec\u00edfico do playbook para deixar mais limpo ou passar as mesmas via linha de comando.","title":"As vari\u00e1veis no ansible"},{"location":"05_playbooks/#variaveis-no-playbook","text":"Para isso, podemos trocar o nome do pacote do pipx no playbook para uma vari\u00e1vel: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux vars : pipx : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : '{{ pipx }}' state : present Assim temos um playbook mais limpo. Pois todo o c\u00f3digo complicado do jinja fica em um lugar espec\u00edfico e no topo do arquivo para ficar f\u00e1cil a consulta. N\u00e3o vou executar esse playbook agora, pois teremos o mesmo resultado da execu\u00e7\u00e3o anterior.","title":"Vari\u00e1veis no playbook"},{"location":"05_playbooks/#variaveis-via-linha-de-comando","text":"Outra funcionalidade importante do ansible \u00e9 conseguir sobrescrever as vari\u00e1veis de um playbook usando a linha de comando como base. Chamar via linha de comando tem uma ordem de preced\u00eancia maior que as vari\u00e1veis definidas no playbook. Ent\u00e3o, quando o ansible for chamado as vari\u00e1veis definidas no campo vars ser\u00e3o substitu\u00eddas pelas vari\u00e1veis que forem passadas na linha de comando: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml --extra-vars \"pipx=pipx\" TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] fatal: [ 10 .0.2.16 ] : FAILED! = > { \"changed\" : false, \"cmd\" : [ \"/usr/bin/pacman\" , \"--upgrade\" , \"--print-format\" , \"%n\" , \"pipx\" ] , \"msg\" : \"Failed to list package pipx\" , \"rc\" : 1 , \"stderr\" : \"error: 'pipx': could not find or read package\\n\" , \"stderr_lines\" : [ \"error: 'pipx': could not find or read package\" ] , \"stdout\" : \"loading packages...\\n\" , \"stdout_lines\" : [ \"loading packages...\" ]} Como era de se esperar, o pacote pipx n\u00e3o existe no arch, seu nome \u00e9 python-pipx por conta disso, o comando n\u00e3o foi executado com sucesso. Nosso objetivo, por\u00e9m, era explorar a chamada de vari\u00e1veis via linha de comando.","title":"Vari\u00e1veis via linha de comando"},{"location":"05_playbooks/#arquivos-de-variaveis","text":"Uma forma de evitar express\u00f5es do jinja e tamb\u00e9m chamar vari\u00e1veis por linha de comando \u00e9 criar um arquivo s\u00f3 para as vari\u00e1veis. Dessa forma, caso tenha alguma vari\u00e1vel que n\u00e3o possa ser exposta, como endere\u00e7o de um banco de dados. Esse valores ficam de fora da configura\u00e7\u00e3o. variaveis.yml 1 2 --- pipx : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" Dessa forma podemos limpar o nosso arquivo pipx_httpie.yml : pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : '{{ pipx }}' state : present E quando formos executar o playbook, s\u00f3 precisamos passar o arquivo de configura\u00e7\u00e3o para as vari\u00e1veis: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml -e @variaveis.yml TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] Assim demos uma limpada no nosso arquivo de playbook e claro, podemos definir diversas outras vari\u00e1veis no arquivo. Mas, voc\u00ea pode tentar depois","title":"Arquivos de vari\u00e1veis"},{"location":"05_playbooks/#arquivos-de-variaveis-por-grupo","text":"Uma outra coisa que pode facilitar na hora de usar as vari\u00e1veis \u00e9 criar vari\u00e1veis espec\u00edficas para grupos. O ansible tem um caminho espec\u00edfico para onde esses arquivos de vari\u00e1veis devem ser colocados: /etc/ansible/group_vars/ . Para resolver isso, vamos criar um grupo de vari\u00e1veis para o ubuntu: /etc/ansible/group_vars/ubuntu.yml 1 2 --- pipx : pipx e um arquivo para o arch: /etc/ansible/group_vars/arch.yml 1 2 --- pipx : python-pipx Dessa forma, quando formos executar o playbook n\u00e3o precisamos mais especificar as vari\u00e1veis comuns. Cada sistema tem sua vers\u00e3o de pipx de acordo com os grupos do invent\u00e1rio: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ]","title":"Arquivos de vari\u00e1veis por grupo"},{"location":"06_tasks/","text":"Tasks","title":"Tasks"},{"location":"06_tasks/#tasks","text":"","title":"Tasks"}]}