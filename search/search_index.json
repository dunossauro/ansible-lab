{"config":{"indexing":"full","lang":["pt"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tutorial introdut\u00f3rio de Ansible V\u00eddeo Reposit\u00f3rio O objetivo desse reposit\u00f3rio \u00e9 ajudar voc\u00ea a construir um laborat\u00f3rio para aprender o b\u00e1sico sobre Ansible. Ele foi criado para uma Live de Python no Youtube. Mas nada impede que voc\u00ea siga somente pelo texto se assim achar necess\u00e1rio. Caso prefira a vers\u00e3o em v\u00eddeo, pode assistir por aqui: Nosso roteiro 00 - Jab\u00e1 01 - Configura\u00e7\u00e3o do ambiente 02 - O b\u00e1sico necess\u00e1rio sobre Vagrant 03 - Ansible b\u00e1sico 04 - Entendendo a estrutura do Ansible 05 - Playbooks 06 - Taks 07 - Ansible Galaxy O que preciso para acompanhar esse tutorial? O b\u00e1sico de Python, pois farei diversas analogias e um computador com pelo menos 8 gigas de mem\u00f3ria RAM para subir as m\u00e1quinas virtuais que vamos configurar durante o tutorial. Navega\u00e7\u00e3o Voc\u00ea pode navegar entre as p\u00e1ginas desse tutorial apertando as teclas . para ir para pr\u00f3xima p\u00e1gina e , para voltar para p\u00e1gina anterior. Caso encontre algum problema Se encontrar algum problema nesse material, como erros, sinta-se a vontade para enviar corre\u00e7\u00f5es no reposit\u00f3rio do projeto . Se precisar me contatar, pode me encontrar nesse link","title":"Tutorial introdut\u00f3rio de Ansible :snake:"},{"location":"#tutorial-introdutorio-de-ansible","text":"V\u00eddeo Reposit\u00f3rio O objetivo desse reposit\u00f3rio \u00e9 ajudar voc\u00ea a construir um laborat\u00f3rio para aprender o b\u00e1sico sobre Ansible. Ele foi criado para uma Live de Python no Youtube. Mas nada impede que voc\u00ea siga somente pelo texto se assim achar necess\u00e1rio. Caso prefira a vers\u00e3o em v\u00eddeo, pode assistir por aqui:","title":"Tutorial introdut\u00f3rio de Ansible"},{"location":"#nosso-roteiro","text":"00 - Jab\u00e1 01 - Configura\u00e7\u00e3o do ambiente 02 - O b\u00e1sico necess\u00e1rio sobre Vagrant 03 - Ansible b\u00e1sico 04 - Entendendo a estrutura do Ansible 05 - Playbooks 06 - Taks 07 - Ansible Galaxy","title":"Nosso roteiro"},{"location":"#o-que-preciso-para-acompanhar-esse-tutorial","text":"O b\u00e1sico de Python, pois farei diversas analogias e um computador com pelo menos 8 gigas de mem\u00f3ria RAM para subir as m\u00e1quinas virtuais que vamos configurar durante o tutorial.","title":"O que preciso para acompanhar esse tutorial?"},{"location":"#navegacao","text":"Voc\u00ea pode navegar entre as p\u00e1ginas desse tutorial apertando as teclas . para ir para pr\u00f3xima p\u00e1gina e , para voltar para p\u00e1gina anterior.","title":"Navega\u00e7\u00e3o"},{"location":"#caso-encontre-algum-problema","text":"Se encontrar algum problema nesse material, como erros, sinta-se a vontade para enviar corre\u00e7\u00f5es no reposit\u00f3rio do projeto . Se precisar me contatar, pode me encontrar nesse link","title":"Caso encontre algum problema"},{"location":"00_jaba/","text":"Jab\u00e1 Como todo in\u00edcio de live que n\u00e3o tem slides eu esque\u00e7o de fazer o Jaba. Todo esse projeto s\u00f3 existe porque \u00e9 financiado por pessoas de bom cora\u00e7\u00e3o nas companhas de financiamento coletivo. Temos v\u00e1rias iniciativas para o financiamento coletivo do projeto Apoia.se : Financiamento recorrente que usamos a mais tempo, 13% do valor fica com a plataforma PicPay : Financiamento recorrente que estamos valorizando recentemente, 2% do valor fica com a plataforma Patreon : Financiamento recorrente para pessoas fora do Brasil Financiamento recorrente \u00e9 a palavra que usamos para quando voc\u00ea deseja doar mensalmente uma quantia fixa. Por exemplo, voc\u00ea pode doar 5 reais todos os meses, isso garante que o projeto continue vivo e ativo por mais tempo. Assim, tenho o planejamento financeiro. Op\u00e7\u00f5es n\u00e3o recorrentes: PicPay : Aqui voc\u00ea pode doar o valor que desejar uma \u00fanica vez, sem se preocupar com recorr\u00eancia Pix: Caso voc\u00ea tenha interesse em fazer uma transfer\u00eancia via PIX > email: pix.dunossauro@gmail.com ou chave aleat\u00f3ria: 5363bcfa-aacd-4a87-84c3-917305af4a65 Nossa comunidade Voc\u00ea pode nos encontrar por meio de v\u00e1rios canais, o geral onde conversamos e tiramos d\u00favidas sobre as lives e python de maneira geral \u00e9 no Telegram . Por\u00e9m voc\u00ea pode nos encontrar em outras redes: https://dunossauro.com/","title":"Jab\u00e1"},{"location":"00_jaba/#jaba","text":"Como todo in\u00edcio de live que n\u00e3o tem slides eu esque\u00e7o de fazer o Jaba. Todo esse projeto s\u00f3 existe porque \u00e9 financiado por pessoas de bom cora\u00e7\u00e3o nas companhas de financiamento coletivo. Temos v\u00e1rias iniciativas para o financiamento coletivo do projeto Apoia.se : Financiamento recorrente que usamos a mais tempo, 13% do valor fica com a plataforma PicPay : Financiamento recorrente que estamos valorizando recentemente, 2% do valor fica com a plataforma Patreon : Financiamento recorrente para pessoas fora do Brasil Financiamento recorrente \u00e9 a palavra que usamos para quando voc\u00ea deseja doar mensalmente uma quantia fixa. Por exemplo, voc\u00ea pode doar 5 reais todos os meses, isso garante que o projeto continue vivo e ativo por mais tempo. Assim, tenho o planejamento financeiro.","title":"Jab\u00e1"},{"location":"00_jaba/#opcoes-nao-recorrentes","text":"PicPay : Aqui voc\u00ea pode doar o valor que desejar uma \u00fanica vez, sem se preocupar com recorr\u00eancia Pix: Caso voc\u00ea tenha interesse em fazer uma transfer\u00eancia via PIX > email: pix.dunossauro@gmail.com ou chave aleat\u00f3ria: 5363bcfa-aacd-4a87-84c3-917305af4a65","title":"Op\u00e7\u00f5es n\u00e3o recorrentes:"},{"location":"00_jaba/#nossa-comunidade","text":"Voc\u00ea pode nos encontrar por meio de v\u00e1rios canais, o geral onde conversamos e tiramos d\u00favidas sobre as lives e python de maneira geral \u00e9 no Telegram . Por\u00e9m voc\u00ea pode nos encontrar em outras redes: https://dunossauro.com/","title":"Nossa comunidade"},{"location":"01_configuracao_do_ambiente/","text":"Configura\u00e7\u00e3o do ambiente A minha ideia principal com esse tutorial \u00e9 n\u00e3o depender de nenhum servi\u00e7o de nuvem. Nem todas as pessoas podem pagar ou tem cart\u00e3o de cr\u00e9dito para poder inserir mesmo nos planos gratuitos. Para n\u00e3o depender de servi\u00e7os externos, vamos usar m\u00e1quinas virtuais com virtualbox e vamos configur\u00e1-las usando Vagrant . Logo, a primeira coisa que precisamos fazer \u00e9 configurar o nosso host para instala\u00e7\u00e3o das m\u00e1quinas virtuais. Para isso, precisamos instalar o virtualbox e o vagrant . Instala\u00e7\u00e3o do virtualbox Virtualbox \u00e9 um software para cria\u00e7\u00e3o de m\u00e1quinas virtuais. E ele pode ser instalado em qualquer plataforma comum do mercado. Como Windows, Linux e MacOS. Caso voc\u00ea use o windows, as instala\u00e7\u00f5es podem ser feitas via chocolatey Voc\u00ea pode fazer o download e instalar ou instalar usando o seu gerenciador de pacotes usando seu terminal preferido: paru -S virtualbox # Arch choco install virtualbox # Windows sudo apt-get install virtualbox # Ubuntu Instala\u00e7\u00e3o do vagrant Vagrant \u00e9 um software de c\u00f3digo aberto, escrito em Ruby para construir ambientes de desenvolvimento usando um arquivo de configura\u00e7\u00e3o. Que pode ser reproduzido por qualquer pessoa que tenha acesso ao arquivo. Abra seu terminal preferido e fa\u00e7a a instala\u00e7\u00e3o: paru -S vagrant # Arch choco install vagrant # Windows sudo apt install vagrant # Ubuntu","title":"Configura\u00e7\u00e3o do ambiente"},{"location":"01_configuracao_do_ambiente/#configuracao-do-ambiente","text":"A minha ideia principal com esse tutorial \u00e9 n\u00e3o depender de nenhum servi\u00e7o de nuvem. Nem todas as pessoas podem pagar ou tem cart\u00e3o de cr\u00e9dito para poder inserir mesmo nos planos gratuitos. Para n\u00e3o depender de servi\u00e7os externos, vamos usar m\u00e1quinas virtuais com virtualbox e vamos configur\u00e1-las usando Vagrant . Logo, a primeira coisa que precisamos fazer \u00e9 configurar o nosso host para instala\u00e7\u00e3o das m\u00e1quinas virtuais. Para isso, precisamos instalar o virtualbox e o vagrant .","title":"Configura\u00e7\u00e3o do ambiente"},{"location":"01_configuracao_do_ambiente/#instalacao-do-virtualbox","text":"Virtualbox \u00e9 um software para cria\u00e7\u00e3o de m\u00e1quinas virtuais. E ele pode ser instalado em qualquer plataforma comum do mercado. Como Windows, Linux e MacOS. Caso voc\u00ea use o windows, as instala\u00e7\u00f5es podem ser feitas via chocolatey Voc\u00ea pode fazer o download e instalar ou instalar usando o seu gerenciador de pacotes usando seu terminal preferido: paru -S virtualbox # Arch choco install virtualbox # Windows sudo apt-get install virtualbox # Ubuntu","title":"Instala\u00e7\u00e3o do virtualbox"},{"location":"01_configuracao_do_ambiente/#instalacao-do-vagrant","text":"Vagrant \u00e9 um software de c\u00f3digo aberto, escrito em Ruby para construir ambientes de desenvolvimento usando um arquivo de configura\u00e7\u00e3o. Que pode ser reproduzido por qualquer pessoa que tenha acesso ao arquivo. Abra seu terminal preferido e fa\u00e7a a instala\u00e7\u00e3o: paru -S vagrant # Arch choco install vagrant # Windows sudo apt install vagrant # Ubuntu","title":"Instala\u00e7\u00e3o do vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/","text":"B\u00e1sico necess\u00e1rio sobre Vagrant Vagrant \u00e9 uma ferramenta para provisionamento de m\u00e1quinas virtuais. Dizendo de forma simples, ele cria e configura m\u00e1quinas virtuais usando um arquivo de configura\u00e7\u00e3o chamado Vagrantfile . Nesse arquivo podemos descrever como nossas vms ser\u00e3o configuradas. Exemplo de um arquivo do Vagrant: Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end A linha destacada \u00e9 referente a um box do Vagrant. Vagrant boxes Um box do vagrant no nosso contexto \u00e9 uma m\u00e1quina virtual pr\u00e9-fabricada por uma pessoa. Existem milhares delas e elas podem ser acessadas no Vagrant Cloud Eu optei por usar m\u00e1quina do arch linux para iniciarmos nossa configura\u00e7\u00e3o. Criando uma m\u00e1quina virtual Nosso primeiro passado \u00e9 copiar o seguinte Vagrantfile : Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end e colocar no diret\u00f3rio do nosso projeto. Que vamos inicialmente chamar de ansible-lab . Dessa forma podemos criar nossa m\u00e1quina virtual usando um simples comando: $ Execu\u00e7\u00e3o no terminal vagrant up O resultado deve ser algo parecido com isso: Bringing machine 'default' up with 'virtualbox' provider... == > default: Importing base box 'archlinux/archlinux' ... == > default: Matching MAC address for NAT networking... == > default: Checking if box 'archlinux/archlinux' version '20221101.99038' is up to date... == > default: Setting the name of the VM: ansible_lab_default_1668393945684_70462 == > default: Clearing any previously set network interfaces... == > default: Preparing network interfaces based on configuration... default: Adapter 1 : nat == > default: Forwarding ports... default: 22 ( guest ) = > 2222 ( host ) ( adapter 1 ) == > default: Booting VM... == > default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127 .0.0.1:2222 default: SSH username: vagrant default: SSH auth method: private key default: Warning: Connection reset. Retrying... default: Warning: Remote connection disconnect. Retrying... default: default: Vagrant insecure key detected. Vagrant will automatically replace default: this with a newly generated keypair for better security. default: default: Inserting generated public key within guest... default: Removing insecure key from the guest if it ' s present... default: Key inserted! Disconnecting and reconnecting using new SSH key... == > default: Machine booted and ready! == > default: Checking for guest additions in VM... == > default: Mounting shared folders... default: /vagrant = > /home/z4r4tu5tr4/ansible_lab E ele criar\u00e1 uma m\u00e1quina virtual com archlinux no nosso virtualbox. OBS: Esse comando pode demorar um pouco, pois ele vai baixar um hd virtual do archlinux e instalar no seu virtualbox. Agora que temos uma m\u00e1quina virtual podemos partir para o segundo passo. Que \u00e9 criar dois n\u00f3s para trabalhar com ansible. Destruindo a m\u00e1quina criada Caso voc\u00ea tenha problemas ou queira simplesmente destruir a m\u00e1quina virutal. O vagrant pode destruir de forma simples a vm e \u00e9 isso que faremos agora. vagrant destroy Com isso podemos ter nosso ambiente limpo outra vez: Configurando mais de uma m\u00e1quina virtual Agora que entendemos a din\u00e2mica de cria\u00e7\u00e3o de vms do vagrant, podemos configurar duas m\u00e1quinas para o ansible. Uma que vamos chamar de main que ser\u00e1 de onde chamaremos o ansible e uma que ser\u00e1 controlada por ele. Que se chamar\u00e1 somente arch . Para isso, s\u00f3 precisamos alterar nosso Vagrantfile : Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end end Agora temos duas m\u00e1quinas virtuais. Uma configurada com Archlinux e uma com Ubuntu Linux. Por\u00e9m, cada uma tem uma fun\u00e7\u00e3o diferente na nossa rede. O vagrant pode subir uma \u00fanica vm ou as duas de uma vez: vagrant up # Inicia as duas vms vagrant up ubuntu # Somente a m\u00e1quina ubuntu vagrant up main # Somente a m\u00e1quina main (vamos escolher essa op\u00e7\u00e3o)","title":"B\u00e1sico necess\u00e1rio sobre Vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/#basico-necessario-sobre-vagrant","text":"Vagrant \u00e9 uma ferramenta para provisionamento de m\u00e1quinas virtuais. Dizendo de forma simples, ele cria e configura m\u00e1quinas virtuais usando um arquivo de configura\u00e7\u00e3o chamado Vagrantfile . Nesse arquivo podemos descrever como nossas vms ser\u00e3o configuradas. Exemplo de um arquivo do Vagrant: Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end A linha destacada \u00e9 referente a um box do Vagrant.","title":"B\u00e1sico necess\u00e1rio sobre Vagrant"},{"location":"02_o_basico_necessario_sobre_vagrant/#vagrant-boxes","text":"Um box do vagrant no nosso contexto \u00e9 uma m\u00e1quina virtual pr\u00e9-fabricada por uma pessoa. Existem milhares delas e elas podem ser acessadas no Vagrant Cloud Eu optei por usar m\u00e1quina do arch linux para iniciarmos nossa configura\u00e7\u00e3o.","title":"Vagrant boxes"},{"location":"02_o_basico_necessario_sobre_vagrant/#criando-uma-maquina-virtual","text":"Nosso primeiro passado \u00e9 copiar o seguinte Vagrantfile : Vagrantfile 1 2 3 Vagrant . configure ( \"2\" ) do | config | config . vm . box = \"archlinux/archlinux\" end e colocar no diret\u00f3rio do nosso projeto. Que vamos inicialmente chamar de ansible-lab . Dessa forma podemos criar nossa m\u00e1quina virtual usando um simples comando: $ Execu\u00e7\u00e3o no terminal vagrant up O resultado deve ser algo parecido com isso: Bringing machine 'default' up with 'virtualbox' provider... == > default: Importing base box 'archlinux/archlinux' ... == > default: Matching MAC address for NAT networking... == > default: Checking if box 'archlinux/archlinux' version '20221101.99038' is up to date... == > default: Setting the name of the VM: ansible_lab_default_1668393945684_70462 == > default: Clearing any previously set network interfaces... == > default: Preparing network interfaces based on configuration... default: Adapter 1 : nat == > default: Forwarding ports... default: 22 ( guest ) = > 2222 ( host ) ( adapter 1 ) == > default: Booting VM... == > default: Waiting for machine to boot. This may take a few minutes... default: SSH address: 127 .0.0.1:2222 default: SSH username: vagrant default: SSH auth method: private key default: Warning: Connection reset. Retrying... default: Warning: Remote connection disconnect. Retrying... default: default: Vagrant insecure key detected. Vagrant will automatically replace default: this with a newly generated keypair for better security. default: default: Inserting generated public key within guest... default: Removing insecure key from the guest if it ' s present... default: Key inserted! Disconnecting and reconnecting using new SSH key... == > default: Machine booted and ready! == > default: Checking for guest additions in VM... == > default: Mounting shared folders... default: /vagrant = > /home/z4r4tu5tr4/ansible_lab E ele criar\u00e1 uma m\u00e1quina virtual com archlinux no nosso virtualbox. OBS: Esse comando pode demorar um pouco, pois ele vai baixar um hd virtual do archlinux e instalar no seu virtualbox. Agora que temos uma m\u00e1quina virtual podemos partir para o segundo passo. Que \u00e9 criar dois n\u00f3s para trabalhar com ansible.","title":"Criando uma m\u00e1quina virtual"},{"location":"02_o_basico_necessario_sobre_vagrant/#destruindo-a-maquina-criada","text":"Caso voc\u00ea tenha problemas ou queira simplesmente destruir a m\u00e1quina virutal. O vagrant pode destruir de forma simples a vm e \u00e9 isso que faremos agora. vagrant destroy Com isso podemos ter nosso ambiente limpo outra vez:","title":"Destruindo a m\u00e1quina criada"},{"location":"02_o_basico_necessario_sobre_vagrant/#configurando-mais-de-uma-maquina-virtual","text":"Agora que entendemos a din\u00e2mica de cria\u00e7\u00e3o de vms do vagrant, podemos configurar duas m\u00e1quinas para o ansible. Uma que vamos chamar de main que ser\u00e1 de onde chamaremos o ansible e uma que ser\u00e1 controlada por ele. Que se chamar\u00e1 somente arch . Para isso, s\u00f3 precisamos alterar nosso Vagrantfile : Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end end Agora temos duas m\u00e1quinas virtuais. Uma configurada com Archlinux e uma com Ubuntu Linux. Por\u00e9m, cada uma tem uma fun\u00e7\u00e3o diferente na nossa rede. O vagrant pode subir uma \u00fanica vm ou as duas de uma vez: vagrant up # Inicia as duas vms vagrant up ubuntu # Somente a m\u00e1quina ubuntu vagrant up main # Somente a m\u00e1quina main (vamos escolher essa op\u00e7\u00e3o)","title":"Configurando mais de uma m\u00e1quina virtual"},{"location":"03_ansible_basico/","text":"Ansible b\u00e1sico Ansible \u00e9 um grupo de ferramentas de c\u00f3digo aberto constru\u00eddas em python. O objetivo do Ansible \u00e9 automatizar tarefas de diversas naturezas. Foi originalmente escrito por Michael DeHaan em 2012 e foi comprado pela Red Hat em 2015. curiosidade A palavra Ansible foi cunhada por Ursula K. Le Guin no livro O mundo de Rocannon No livro existem diversos mundos e viajantes navegam na velocidade da luz. Ansible \u00e9 um dispositivo que de comunica\u00e7\u00e3o instant\u00e2nea pelo universo. Automa\u00e7\u00f5es Quando falamos sobre Ansible, estamos falando sobre qualquer tipo de automa\u00e7\u00e3o em m\u00e1quinas. Alguns exemplos comuns s\u00e3o: Provisionamento de ambientes Gerenciamento de configura\u00e7\u00e3o Implanta\u00e7\u00e3o de aplicativos Entre outras coisas que podemos fazer com o ferramental Provisionamento Provisionamento \u00e9 o processo de preparar um dispositivo para que ele possa entrar em produ\u00e7\u00e3o. N\u00e3o s\u00f3 exatamente a respeito do hardware, mas a prepara\u00e7\u00e3o do sistema operacional, a escolha dos aplicativos instalados e etc... Vimos nesse pequeno tutorial outra ferramenta de provisionamento, o Vagrant, que consegue montar a m\u00e1quina virtual, fornecer a instala\u00e7\u00e3o do sistema operacional. A parte que envolve o ansible \u00e9 mais referente a configura\u00e7\u00e3o dos pacotes instalados, a instala\u00e7\u00e3o dos softwares necess\u00e1rios para colocar uma m\u00e1quina, geralmente um servidor, em funcionamento. Gerenciamento de configura\u00e7\u00e3o O gerenciamento de configura\u00e7\u00e3o \u00e9 uma das partes do provisionamento, por\u00e9m com foco e configurar as aplica\u00e7\u00f5es instaladas no sistema operacional para que ele se comporte como esperado em produ\u00e7\u00e3o. Implanta\u00e7\u00e3o de aplicativos Ap\u00f3s toda a fase de instala\u00e7\u00e3o e configura\u00e7\u00e3o do ambiente e do sistema operacional, podemos colocar nossos aplicativos para serem executados nessas m\u00e1quinas. Um exemplo Vamos pensar que fizemos uma aplica\u00e7\u00e3o web com Python. Para que essa aplica\u00e7\u00e3o seja usada em um servidor o servidor tem que atender diversos requisitos para executar a nossa aplica\u00e7\u00e3o. Independentemente da op\u00e7\u00e3o que voc\u00ea escolha para fazer o deploy dela. De forma simples, temos que instalar o python na vers\u00e3o correta, fazer a instala\u00e7\u00e3o das bibliotecas necess\u00e1rias, configurar um banco de dados. Fazer com que a aplica\u00e7\u00e3o e o banco de dados conversem. Para que isso ocorra na nuvem, por exemplo, algu\u00e9m deve ter provisionado um sistema base, como um ubuntu linux , geralmente usando algum sistema de virtualiza\u00e7\u00e3o. Como fizemos aqui com VirtualBox, por\u00e9m em uma escala muito maior. Essa m\u00e1quina tem que ter ao menos um servi\u00e7o de SSH configurado para que possamos acessar esse computador do conforto da nossa casa. \u00c9 nesse contexto que o Ansible entra. Pegamos um sistema operacional limpo e iniciamos as nossas configura\u00e7\u00f5es e instala\u00e7\u00f5es para que nossa aplica\u00e7\u00e3o possa ser executada nesse servidor. Instala\u00e7\u00e3o do ansible Agora que temos duas m\u00e1quinas virtuais criadas. Podemos come\u00e7ar a instala\u00e7\u00e3o do ansible. A primeira coisa que devemos fazer \u00e9 acessar a m\u00e1quina controladora. Para isso podemos usar o vagrant para nos ajudar: $ Execu\u00e7\u00e3o no terminal vagrant up main # Iniciar a m\u00e1quina controladora vagrant ssh main # Acessar o console da m\u00e1quina controladora via ssh E isso deve retornar o console d\u00e1 maquina controladora no usu\u00e1rio vagrant : O ansible tem seus pacotes nos reposit\u00f3rios de quase todas as distribui\u00e7\u00f5es linux. Ent\u00e3o voc\u00ea pode instalar no seu sistema como quiser. Caso tenha d\u00favidas, o link da documenta\u00e7\u00e3o Formas de instalar em diversos sistemas. $ Execu\u00e7\u00e3o no terminal sudo pacman -S ansible # Arch sudo apt install ansible # Ubuntu sudo dnf ansible # Familia Redhat O ansible tamb\u00e9m pode ser instalado via pip , por\u00e9m a instala\u00e7\u00e3o \u00e9 bastante trabalhosa. Como eu escolhi que a m\u00e1quina main fosse um archlinux, vamos seguir a configura\u00e7\u00e3o com ele. O primeiro passo que devemos fazer \u00e9 atualizar a m\u00e1quina para garantir que tudo funcione como o esperado: sudo pacman -Syu # Atualiza o sistema Caso a senha perguntada. A senha padr\u00e3o criada pelas m\u00e1quinas virtuais do vagrant \u00e9 vagrant . Agora podemos rodar o comando para instalar o ansible: $ Execu\u00e7\u00e3o no terminal sudo pacman -S ansible Se tudo ocorrer como o esperado, podemos perguntar a vers\u00e3o do ansible ao sistema: $ Execu\u00e7\u00e3o no terminal [ vagrant@archlinux ~ ] $ ansible --version ansible [ core 2 .14.0 ] config file = /etc/ansible/ansible.cfg configured module search path = [ '/home/vagrant/.ansible/plugins/modules' , '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/lib/python3.10/site-packages/ansible ansible collection location = /home/vagrant/.ansible/collections:/usr/share/ansible/collections executable location = /usr/bin/ansible python version = 3 .10.8 ( main, Nov 1 2022 , 14 :18:21 ) [ GCC 12 .2.0 ] ( /usr/bin/python ) jinja version = 3 .1.2 libyaml = True Ele nos disse que est\u00e1 na vers\u00e3o 3.10.8 Um pouco de ansible na pr\u00e1tica O ansible foi pensado para que pud\u00e9ssemos automatizar uma tarefa de qualquer natureza. Para isso basta ter o ansible instalado na sua m\u00e1quina e cham\u00e1-lo via linha de comando. Instala\u00e7\u00e3o de um pacote Por exemplo, vamos supor que no nosso ambiente \u00e9 imprescind\u00edvel que o editor de texto GNU/Emacs esteja instalado (para mim costuma ser). Ent\u00e3o podemos usar o ansible para instalar o Emacs no nosso computador pessoal: $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=emacs state=present\" -b Com esse simples comando, temos o GNU/Emacs instalado nesse computador. Mas, o que realmente aconteceu aqui? Fragmento do comando O que faz? ansible Invoca o ansible localhost Diz qual m\u00e1quina ser\u00e1 afetada pelo comando -m Diz que vamos chamar um m\u00f3dulo package package \u00e9 o nome do m\u00f3dulo que vamos chamar -a Indica que vamos passar argumentos para o m\u00f3dulo \"name=emacs state=present\" Argumentos do m\u00f3dulo -b Diz ao Ansible que o comando ser\u00e1 executado como root O m\u00f3dulo package \u00e9 um dos muitos m\u00f3dulos ofertados pelo Ansible. Voc\u00ea pode ver uma lista completa aqui nesse link . O que dissemos, por\u00e9m, \u00e9: \"Modulo package garanta que o pacote emacs esteja presente no sistema em que for executado\". Podemos checar no terminal: $ Execu\u00e7\u00e3o no terminal emacs Caso tenha ficado preso Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs Configura\u00e7\u00e3o do pacote Embora o GNU/Emacs esteja instalado no meu sistema. Ele ainda n\u00e3o foi configurado da maneira que eu gostaria. N\u00e3o tem as minhas cores, os meus atalhos e para isso precisamos baixar meu arquivo de configura\u00e7\u00e3o que est\u00e1 no github.com/dunossauro/dotfiles . Para isso, podemos contar com outro m\u00f3dulo dispon\u00edvel no Ansible, o git . Ent\u00e3o, vamos baixar as minhas configura\u00e7\u00f5es: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" E com isso, obtivemos um erro: Resposta do terminal localhost | FAILED! = > { \"changed\" : false, \"msg\" : \"Failed to find required executable \\\"git\\\" in paths: /usr/local/sbin:/usr/local/bin:/usr/bin:/sbin:/usr/sbin\" } O ansible n\u00e3o conseguiu achar o git no nosso sistema, ele precisa ser instalado. Como j\u00e1 conhecemos o m\u00f3dulo package, ser\u00e1 f\u00e1cil. S\u00f3 dizer ao m\u00f3dulo package que git deve estar present : $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=git state=present\" -b Ap\u00f3s instalar o git, podemos testar nosso m\u00f3dulo de git outra vez: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" Resposta do terminal localhost | CHANGED = > { \"after\" : \"8ff42a43ede85403b6b85c0bab9a1a4fe0d73544\" , \"before\" : null, \"changed\" : true } CHANGED , significa que uma a\u00e7\u00e3o foi executada e agora temos os arquivos no nosso computador na pasta dest que passamos como argumento. $ Execu\u00e7\u00e3o no terminal ls config_files/.emacs.d init.el Agora s\u00f3 falta colocar a nossa configura\u00e7\u00e3o no lugar certo. O diret\u00f3rio ~/.emacs.d/ . Para isso podemos contar com outro m\u00f3dulo do copy : $ Execu\u00e7\u00e3o no terminal ansible localhost -m copy -a \"dest='/home/vagrant/' src='/home/vagrant/config_files/.emacs.d'\" Ap\u00f3s isso, podemos abrir o emacs novamente: $ Execu\u00e7\u00e3o no terminal emacs Pode demorar um pouco para as configura\u00e7\u00f5es serem baixadas e instaladas da internet. E temos o emacs com as minhas configura\u00e7\u00f5es: Caso tenha ficado preso OUTRA VEZ Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Ansible b\u00e1sico"},{"location":"03_ansible_basico/#ansible-basico","text":"Ansible \u00e9 um grupo de ferramentas de c\u00f3digo aberto constru\u00eddas em python. O objetivo do Ansible \u00e9 automatizar tarefas de diversas naturezas. Foi originalmente escrito por Michael DeHaan em 2012 e foi comprado pela Red Hat em 2015. curiosidade A palavra Ansible foi cunhada por Ursula K. Le Guin no livro O mundo de Rocannon No livro existem diversos mundos e viajantes navegam na velocidade da luz. Ansible \u00e9 um dispositivo que de comunica\u00e7\u00e3o instant\u00e2nea pelo universo.","title":"Ansible b\u00e1sico"},{"location":"03_ansible_basico/#automacoes","text":"Quando falamos sobre Ansible, estamos falando sobre qualquer tipo de automa\u00e7\u00e3o em m\u00e1quinas. Alguns exemplos comuns s\u00e3o: Provisionamento de ambientes Gerenciamento de configura\u00e7\u00e3o Implanta\u00e7\u00e3o de aplicativos Entre outras coisas que podemos fazer com o ferramental","title":"Automa\u00e7\u00f5es"},{"location":"03_ansible_basico/#provisionamento","text":"Provisionamento \u00e9 o processo de preparar um dispositivo para que ele possa entrar em produ\u00e7\u00e3o. N\u00e3o s\u00f3 exatamente a respeito do hardware, mas a prepara\u00e7\u00e3o do sistema operacional, a escolha dos aplicativos instalados e etc... Vimos nesse pequeno tutorial outra ferramenta de provisionamento, o Vagrant, que consegue montar a m\u00e1quina virtual, fornecer a instala\u00e7\u00e3o do sistema operacional. A parte que envolve o ansible \u00e9 mais referente a configura\u00e7\u00e3o dos pacotes instalados, a instala\u00e7\u00e3o dos softwares necess\u00e1rios para colocar uma m\u00e1quina, geralmente um servidor, em funcionamento.","title":"Provisionamento"},{"location":"03_ansible_basico/#gerenciamento-de-configuracao","text":"O gerenciamento de configura\u00e7\u00e3o \u00e9 uma das partes do provisionamento, por\u00e9m com foco e configurar as aplica\u00e7\u00f5es instaladas no sistema operacional para que ele se comporte como esperado em produ\u00e7\u00e3o.","title":"Gerenciamento de configura\u00e7\u00e3o"},{"location":"03_ansible_basico/#implantacao-de-aplicativos","text":"Ap\u00f3s toda a fase de instala\u00e7\u00e3o e configura\u00e7\u00e3o do ambiente e do sistema operacional, podemos colocar nossos aplicativos para serem executados nessas m\u00e1quinas.","title":"Implanta\u00e7\u00e3o de aplicativos"},{"location":"03_ansible_basico/#um-exemplo","text":"Vamos pensar que fizemos uma aplica\u00e7\u00e3o web com Python. Para que essa aplica\u00e7\u00e3o seja usada em um servidor o servidor tem que atender diversos requisitos para executar a nossa aplica\u00e7\u00e3o. Independentemente da op\u00e7\u00e3o que voc\u00ea escolha para fazer o deploy dela. De forma simples, temos que instalar o python na vers\u00e3o correta, fazer a instala\u00e7\u00e3o das bibliotecas necess\u00e1rias, configurar um banco de dados. Fazer com que a aplica\u00e7\u00e3o e o banco de dados conversem. Para que isso ocorra na nuvem, por exemplo, algu\u00e9m deve ter provisionado um sistema base, como um ubuntu linux , geralmente usando algum sistema de virtualiza\u00e7\u00e3o. Como fizemos aqui com VirtualBox, por\u00e9m em uma escala muito maior. Essa m\u00e1quina tem que ter ao menos um servi\u00e7o de SSH configurado para que possamos acessar esse computador do conforto da nossa casa. \u00c9 nesse contexto que o Ansible entra. Pegamos um sistema operacional limpo e iniciamos as nossas configura\u00e7\u00f5es e instala\u00e7\u00f5es para que nossa aplica\u00e7\u00e3o possa ser executada nesse servidor.","title":"Um exemplo"},{"location":"03_ansible_basico/#instalacao-do-ansible","text":"Agora que temos duas m\u00e1quinas virtuais criadas. Podemos come\u00e7ar a instala\u00e7\u00e3o do ansible. A primeira coisa que devemos fazer \u00e9 acessar a m\u00e1quina controladora. Para isso podemos usar o vagrant para nos ajudar: $ Execu\u00e7\u00e3o no terminal vagrant up main # Iniciar a m\u00e1quina controladora vagrant ssh main # Acessar o console da m\u00e1quina controladora via ssh E isso deve retornar o console d\u00e1 maquina controladora no usu\u00e1rio vagrant : O ansible tem seus pacotes nos reposit\u00f3rios de quase todas as distribui\u00e7\u00f5es linux. Ent\u00e3o voc\u00ea pode instalar no seu sistema como quiser. Caso tenha d\u00favidas, o link da documenta\u00e7\u00e3o Formas de instalar em diversos sistemas. $ Execu\u00e7\u00e3o no terminal sudo pacman -S ansible # Arch sudo apt install ansible # Ubuntu sudo dnf ansible # Familia Redhat O ansible tamb\u00e9m pode ser instalado via pip , por\u00e9m a instala\u00e7\u00e3o \u00e9 bastante trabalhosa. Como eu escolhi que a m\u00e1quina main fosse um archlinux, vamos seguir a configura\u00e7\u00e3o com ele. O primeiro passo que devemos fazer \u00e9 atualizar a m\u00e1quina para garantir que tudo funcione como o esperado: sudo pacman -Syu # Atualiza o sistema Caso a senha perguntada. A senha padr\u00e3o criada pelas m\u00e1quinas virtuais do vagrant \u00e9 vagrant . Agora podemos rodar o comando para instalar o ansible: $ Execu\u00e7\u00e3o no terminal sudo pacman -S ansible Se tudo ocorrer como o esperado, podemos perguntar a vers\u00e3o do ansible ao sistema: $ Execu\u00e7\u00e3o no terminal [ vagrant@archlinux ~ ] $ ansible --version ansible [ core 2 .14.0 ] config file = /etc/ansible/ansible.cfg configured module search path = [ '/home/vagrant/.ansible/plugins/modules' , '/usr/share/ansible/plugins/modules' ] ansible python module location = /usr/lib/python3.10/site-packages/ansible ansible collection location = /home/vagrant/.ansible/collections:/usr/share/ansible/collections executable location = /usr/bin/ansible python version = 3 .10.8 ( main, Nov 1 2022 , 14 :18:21 ) [ GCC 12 .2.0 ] ( /usr/bin/python ) jinja version = 3 .1.2 libyaml = True Ele nos disse que est\u00e1 na vers\u00e3o 3.10.8","title":"Instala\u00e7\u00e3o do ansible"},{"location":"03_ansible_basico/#um-pouco-de-ansible-na-pratica","text":"O ansible foi pensado para que pud\u00e9ssemos automatizar uma tarefa de qualquer natureza. Para isso basta ter o ansible instalado na sua m\u00e1quina e cham\u00e1-lo via linha de comando.","title":"Um pouco de ansible na pr\u00e1tica"},{"location":"03_ansible_basico/#instalacao-de-um-pacote","text":"Por exemplo, vamos supor que no nosso ambiente \u00e9 imprescind\u00edvel que o editor de texto GNU/Emacs esteja instalado (para mim costuma ser). Ent\u00e3o podemos usar o ansible para instalar o Emacs no nosso computador pessoal: $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=emacs state=present\" -b Com esse simples comando, temos o GNU/Emacs instalado nesse computador. Mas, o que realmente aconteceu aqui? Fragmento do comando O que faz? ansible Invoca o ansible localhost Diz qual m\u00e1quina ser\u00e1 afetada pelo comando -m Diz que vamos chamar um m\u00f3dulo package package \u00e9 o nome do m\u00f3dulo que vamos chamar -a Indica que vamos passar argumentos para o m\u00f3dulo \"name=emacs state=present\" Argumentos do m\u00f3dulo -b Diz ao Ansible que o comando ser\u00e1 executado como root O m\u00f3dulo package \u00e9 um dos muitos m\u00f3dulos ofertados pelo Ansible. Voc\u00ea pode ver uma lista completa aqui nesse link . O que dissemos, por\u00e9m, \u00e9: \"Modulo package garanta que o pacote emacs esteja presente no sistema em que for executado\". Podemos checar no terminal: $ Execu\u00e7\u00e3o no terminal emacs Caso tenha ficado preso Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Instala\u00e7\u00e3o de um pacote"},{"location":"03_ansible_basico/#configuracao-do-pacote","text":"Embora o GNU/Emacs esteja instalado no meu sistema. Ele ainda n\u00e3o foi configurado da maneira que eu gostaria. N\u00e3o tem as minhas cores, os meus atalhos e para isso precisamos baixar meu arquivo de configura\u00e7\u00e3o que est\u00e1 no github.com/dunossauro/dotfiles . Para isso, podemos contar com outro m\u00f3dulo dispon\u00edvel no Ansible, o git . Ent\u00e3o, vamos baixar as minhas configura\u00e7\u00f5es: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" E com isso, obtivemos um erro: Resposta do terminal localhost | FAILED! = > { \"changed\" : false, \"msg\" : \"Failed to find required executable \\\"git\\\" in paths: /usr/local/sbin:/usr/local/bin:/usr/bin:/sbin:/usr/sbin\" } O ansible n\u00e3o conseguiu achar o git no nosso sistema, ele precisa ser instalado. Como j\u00e1 conhecemos o m\u00f3dulo package, ser\u00e1 f\u00e1cil. S\u00f3 dizer ao m\u00f3dulo package que git deve estar present : $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=git state=present\" -b Ap\u00f3s instalar o git, podemos testar nosso m\u00f3dulo de git outra vez: $ Execu\u00e7\u00e3o no terminal ansible localhost -m git \\ -a \"repo=https://github.com/dunossauro/dotfiles.git dest=config_files\" Resposta do terminal localhost | CHANGED = > { \"after\" : \"8ff42a43ede85403b6b85c0bab9a1a4fe0d73544\" , \"before\" : null, \"changed\" : true } CHANGED , significa que uma a\u00e7\u00e3o foi executada e agora temos os arquivos no nosso computador na pasta dest que passamos como argumento. $ Execu\u00e7\u00e3o no terminal ls config_files/.emacs.d init.el Agora s\u00f3 falta colocar a nossa configura\u00e7\u00e3o no lugar certo. O diret\u00f3rio ~/.emacs.d/ . Para isso podemos contar com outro m\u00f3dulo do copy : $ Execu\u00e7\u00e3o no terminal ansible localhost -m copy -a \"dest='/home/vagrant/' src='/home/vagrant/config_files/.emacs.d'\" Ap\u00f3s isso, podemos abrir o emacs novamente: $ Execu\u00e7\u00e3o no terminal emacs Pode demorar um pouco para as configura\u00e7\u00f5es serem baixadas e instaladas da internet. E temos o emacs com as minhas configura\u00e7\u00f5es: Caso tenha ficado preso OUTRA VEZ Para sair do emacs tecle Alt+x e em seguida digite kill-emacs e voc\u00ea ter\u00e1 sa\u00eddo do emacs","title":"Configura\u00e7\u00e3o do pacote"},{"location":"04_configuracao_do_ansible/","text":"Entendendo a estrutura do ansible Embora at\u00e9 o momento executamos o ansible somente em uma m\u00e1quina local. E confesso que j\u00e1 pode ser bastante \u00fatil para padronizar suas configura\u00e7\u00f5es ap\u00f3s uma formata\u00e7\u00e3o, por exemplo. O Ansible brilha quando estamos falando de rede. Arquitetura de uso do ansible O Ansible distingue as m\u00e1quinas em duas categorias. O n\u00f3 de controle, onde o ansible est\u00e1 instalado e os n\u00f3s controlados. Que m\u00e1quinas em que o ansible pode se comunicar via SSH e executar os comandos: Dessa forma podemos partir do n\u00f3 de Controle e enviar rotinas de automa\u00e7\u00e3o para todos os n\u00f3s Controlados . Para isso o ansible conta com um arquivo de invent\u00e1rio. Um lugar onde todas as m\u00e1quinas que ser\u00e3o controladas pelo controlador devem ser registradas. Arquivo de invent\u00e1rio Por padr\u00e3o o arquivo de invent\u00e1rio das m\u00e1quinas ficam no /etc/ansible/hosts . Vamos criar esse arquivo agora. $ Execu\u00e7\u00e3o no terminal # instala\u00e7\u00e3o do Nano, n\u00e3o vou obrigar ningu\u00e9m a usar o Emacs ;) ansible localhost -m package -a \"name=emacs state=present\" -b sudo nano /etc/ansible/hosts \u00c9 nesse arquivo que colocamos os endere\u00e7os dos n\u00f3s que ser\u00e3o controlados pelo ansible. O arquivo tem o seguinte formato: [<nome_do_grupo>] <endere\u00e7o_da_maquina> <op\u00e7\u00f5es> Por exemplo, vamos cadastrar nossa outra vm arch que ser\u00e1 controlado pelo main . Para isso, precisamos iniciar essa m\u00e1quina virtual. Antes disso, temos que sair do ssh em main : $ Execu\u00e7\u00e3o no terminal exit Agora voltamos a m\u00e1quina principal. A m\u00e1quina onde as m\u00e1quinas virtuais foram instaladas. Vamos iniciar nossa outra m\u00e1quina. O ubuntu : vagrant up ubuntu Com isso, agora devemos ter duas m\u00e1quinas no nosso virtual box: [AA] - Mudar essa imagem Com nossa vm j\u00e1 de p\u00e9, podemos enviar um comando para o vagrant nos dizer o endere\u00e7o ip da m\u00e1quina ubuntu : $ Execu\u00e7\u00e3o no terminal vagrant ssh ubuntu -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.15 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Podemos ver que o IP associado a ubuntu \u00e9 10.0.2.15 . Que \u00e9 o endere\u00e7o que colocaremos no nosso invent\u00e1rio. Agora vamos voltar a nossa m\u00e1quina main via ssh: $ Execu\u00e7\u00e3o no terminal vagrant ssh main E vamos alterar nosso arquivo /etc/ansible/hosts dessa forma e com o comando sudo nano /etc/ansible/hosts : /etc/ansible/hosts 1 2 [ubuntu] 10.0.2.15 Dessa forma dissemos ao ansible que existe um grupo chamado ubuntu , uma dessas m\u00e1quinas tem o ip 10.0.2.15 . Assim, podemos enviar comandos para o grupo ubuntu . Primeiro comando remoto E podemos checar enviando um ping para a vm ubuntu usando o seguinte comando ansible ubuntu -m ping : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m ping The authenticity of host '10.0.2.15 (10.0.2.15)' can 't be established. ED25519 key fingerprint is SHA256:FyOy2yTlOHSLJXVF+lmYjPywdfmQprApMWrsQ7KxUlI. This host key is known by the following other names/addresses: ~/.ssh/known_hosts:1: localhost Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 10.0.2.15 | UNREACHABLE! => { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: Warning: Permanently added ' 10 .0.2.15 ' ( ED25519 ) to the list of known hosts. \\r\\n vagrant@10.0.2.15: Permission denied ( publickey,password ) . \", \" unreachable \": true } Um erro ocorreu por conta da seguran\u00e7a. O SSH da vm ubuntu n\u00e3o permitiu que o ansible fizesse a conex\u00e3o. Para isso precisamos trocar chaves entre os hosts para que aconte\u00e7a de maneira segura. Troca de chaves SSH Vamos voltar ao shell e digitar os seguintes comandos: $ Execu\u00e7\u00e3o no terminal ssh-keygen # para gerar uma chave ssh para nossa vm `main` ssh-copy-id vagrant@10.0.2.15 # Para copiar a chave de `main` para `ubuntu` Se executarmos o ping novamente obteremos sucesso: $ Execu\u00e7\u00e3o no terminal ansible arch -m ping 10 .0.2.15 | SUCCESS = > { \"ansible_facts\" : { \"discovered_interpreter_python\" : \"/usr/bin/python3.10\" } , \"changed\" : false, \"ping\" : \"pong\" } Isso significa que a comunica\u00e7\u00e3o com os dois n\u00f3s est\u00e1 acontecendo de maneira correta. Mas, faltou entender o que o comando ansible ubuntu -m ping significa: ansible: Chama o ansible ubuntu: O nome do grupo do invent\u00e1rio -m: Significa que vamos chamar um m\u00f3dulo ping: M\u00f3dulo para checar se o grupo est\u00e1 respondendo Repetindo o processo para mais uma m\u00e1quina Agora que j\u00e1 entendemos o que temos que fazer. Podemos adicionar mais uma m\u00e1quina virtual ao nosso ambiente. Vamos criar mais um arch para que seja controlado pelo ansible: Vagrantfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end config . vm . define \"arch\" do | arch | arch . vm . box = \"archlinux/archlinux\" end end Agora podemos dar up nessa nova m\u00e1quina: $ Execu\u00e7\u00e3o no terminal exit # caso esteja no conectado no main vagrant up arch Pegamos o endere\u00e7o de ip: $ Execu\u00e7\u00e3o no terminal vagrant ssh arch -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.16 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Adicionamos esse ip no invent\u00e1rio da m\u00e1quina controladora: /etc/ansible/hosts 1 2 3 4 5 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 Fazemos a troca de chaves SSH, para que o Controlador se comunique de forma segura com o arch : $ Execu\u00e7\u00e3o no terminal ssh-copy-id vagrant@10.0.2.16 # Para copiar a chave de `main` para `arch` Com isso temos dois grupos no n\u00f3 de controle. O ubuntu e o arch . Podemos criar um grupo novo tamb\u00e9m para juntar todos os linux e disparar comandos que funcionem nas duas m\u00e1quinas ao mesmo tempo: /etc/ansible/hosts 1 2 3 4 5 6 7 8 9 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 [linux] 10.0.2.15 10.0.2.16 Dessa forma, podemos chamar o m\u00f3dulo ping para todos os n\u00f3s em um grupo s\u00f3: $ Execu\u00e7\u00e3o no terminal ansible linux -m ping Caso tudo esteja configurado corretamente. Iremos obter sucesso em ambos os pings. O que significa que o comando foi executado com sucesso nas duas m\u00e1quinas. Instalando um pacote em dois n\u00f3s ao mesmo tempo Vamos iniciar uma configura\u00e7\u00e3o simples e que j\u00e1 rodamos no n\u00f3 controlador. Meu objetivo, por\u00e9m, \u00e9 mostrar a voc\u00eas o poder do ansible de forma simples: $ Execu\u00e7\u00e3o no terminal ansible linux -m package -a \"name=nginx state=present\" -b Dessa forma acabamos de instalar o servidor web Nginx nas nossas duas m\u00e1quinas virtuais ao mesmo tempo. Uma coisa importante de notar e que diferencia de uma forma simpl\u00f3ria de instala\u00e7\u00e3o. \u00c9 que n\u00e3o foi preciso dizer nem ao menos qual o gerenciador de pacotes que \u00e9 usado em cada distribui\u00e7\u00e3o. O m\u00f3dulo package entende isso por padr\u00e3o e usa o gerenciador da distribui\u00e7\u00e3o por baixo dos panos. Com isso, podemos conhecer outro m\u00f3dulo. O m\u00f3dulo do systemd e com ele podemos dizer que queremos dar start no processo do Nginx: $ Execu\u00e7\u00e3o no terminal ansible linux -m systemd -a \"name=nginx state=started\" -b E vol\u00e1, instalamos o Nginx em duas m\u00e1quinas e subimos o server somente usando comandos simples e sem a preocupa\u00e7\u00e3o de ter de entender coisas espec\u00edficas de sistema. Vamos ver se o servi\u00e7o subiu da forma correta? Para isso vou me aproveitar do ansible para instalar o httpie no sistema para fazer essa requisi\u00e7\u00e3o no n\u00f3 controlador. Por\u00e9m, n\u00e3o quero fazer essa instala\u00e7\u00e3o sujando o ambiente. Ent\u00e3o, vamos instalar o pipx $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=python-pipx state=present\" -b Agora com o pipx instalado, podemos usar ele via m\u00f3dulo shell para instalar o httpie: $ Execu\u00e7\u00e3o no terminal ansible localhost -m shell -a \"pipx install httpie\" E agora, finalmente, podemos checar se ambos os servi\u00e7os foram startados corretamente pelo ansible: $ Execu\u00e7\u00e3o no terminal http 10 .0.2.15 http 10 .0.2.16 Embora tudo tenha sido executado de forma incr\u00edvel. Ainda considero chato de mais ficar chamando o ansible no terminal o tempo todo. Ent\u00e3o, precisamos de uma forma de melhorar isso.","title":"Entendendo a estrutura do ansible"},{"location":"04_configuracao_do_ansible/#entendendo-a-estrutura-do-ansible","text":"Embora at\u00e9 o momento executamos o ansible somente em uma m\u00e1quina local. E confesso que j\u00e1 pode ser bastante \u00fatil para padronizar suas configura\u00e7\u00f5es ap\u00f3s uma formata\u00e7\u00e3o, por exemplo. O Ansible brilha quando estamos falando de rede.","title":"Entendendo a estrutura do ansible"},{"location":"04_configuracao_do_ansible/#arquitetura-de-uso-do-ansible","text":"O Ansible distingue as m\u00e1quinas em duas categorias. O n\u00f3 de controle, onde o ansible est\u00e1 instalado e os n\u00f3s controlados. Que m\u00e1quinas em que o ansible pode se comunicar via SSH e executar os comandos: Dessa forma podemos partir do n\u00f3 de Controle e enviar rotinas de automa\u00e7\u00e3o para todos os n\u00f3s Controlados . Para isso o ansible conta com um arquivo de invent\u00e1rio. Um lugar onde todas as m\u00e1quinas que ser\u00e3o controladas pelo controlador devem ser registradas.","title":"Arquitetura de uso do ansible"},{"location":"04_configuracao_do_ansible/#arquivo-de-inventario","text":"Por padr\u00e3o o arquivo de invent\u00e1rio das m\u00e1quinas ficam no /etc/ansible/hosts . Vamos criar esse arquivo agora. $ Execu\u00e7\u00e3o no terminal # instala\u00e7\u00e3o do Nano, n\u00e3o vou obrigar ningu\u00e9m a usar o Emacs ;) ansible localhost -m package -a \"name=emacs state=present\" -b sudo nano /etc/ansible/hosts \u00c9 nesse arquivo que colocamos os endere\u00e7os dos n\u00f3s que ser\u00e3o controlados pelo ansible. O arquivo tem o seguinte formato: [<nome_do_grupo>] <endere\u00e7o_da_maquina> <op\u00e7\u00f5es> Por exemplo, vamos cadastrar nossa outra vm arch que ser\u00e1 controlado pelo main . Para isso, precisamos iniciar essa m\u00e1quina virtual. Antes disso, temos que sair do ssh em main : $ Execu\u00e7\u00e3o no terminal exit Agora voltamos a m\u00e1quina principal. A m\u00e1quina onde as m\u00e1quinas virtuais foram instaladas. Vamos iniciar nossa outra m\u00e1quina. O ubuntu : vagrant up ubuntu Com isso, agora devemos ter duas m\u00e1quinas no nosso virtual box: [AA] - Mudar essa imagem Com nossa vm j\u00e1 de p\u00e9, podemos enviar um comando para o vagrant nos dizer o endere\u00e7o ip da m\u00e1quina ubuntu : $ Execu\u00e7\u00e3o no terminal vagrant ssh ubuntu -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.15 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Podemos ver que o IP associado a ubuntu \u00e9 10.0.2.15 . Que \u00e9 o endere\u00e7o que colocaremos no nosso invent\u00e1rio. Agora vamos voltar a nossa m\u00e1quina main via ssh: $ Execu\u00e7\u00e3o no terminal vagrant ssh main E vamos alterar nosso arquivo /etc/ansible/hosts dessa forma e com o comando sudo nano /etc/ansible/hosts : /etc/ansible/hosts 1 2 [ubuntu] 10.0.2.15 Dessa forma dissemos ao ansible que existe um grupo chamado ubuntu , uma dessas m\u00e1quinas tem o ip 10.0.2.15 . Assim, podemos enviar comandos para o grupo ubuntu .","title":"Arquivo de invent\u00e1rio"},{"location":"04_configuracao_do_ansible/#primeiro-comando-remoto","text":"E podemos checar enviando um ping para a vm ubuntu usando o seguinte comando ansible ubuntu -m ping : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m ping The authenticity of host '10.0.2.15 (10.0.2.15)' can 't be established. ED25519 key fingerprint is SHA256:FyOy2yTlOHSLJXVF+lmYjPywdfmQprApMWrsQ7KxUlI. This host key is known by the following other names/addresses: ~/.ssh/known_hosts:1: localhost Are you sure you want to continue connecting (yes/no/[fingerprint])? yes 10.0.2.15 | UNREACHABLE! => { \"changed\": false, \"msg\": \"Failed to connect to the host via ssh: Warning: Permanently added ' 10 .0.2.15 ' ( ED25519 ) to the list of known hosts. \\r\\n vagrant@10.0.2.15: Permission denied ( publickey,password ) . \", \" unreachable \": true } Um erro ocorreu por conta da seguran\u00e7a. O SSH da vm ubuntu n\u00e3o permitiu que o ansible fizesse a conex\u00e3o. Para isso precisamos trocar chaves entre os hosts para que aconte\u00e7a de maneira segura.","title":"Primeiro comando remoto"},{"location":"04_configuracao_do_ansible/#troca-de-chaves-ssh","text":"Vamos voltar ao shell e digitar os seguintes comandos: $ Execu\u00e7\u00e3o no terminal ssh-keygen # para gerar uma chave ssh para nossa vm `main` ssh-copy-id vagrant@10.0.2.15 # Para copiar a chave de `main` para `ubuntu` Se executarmos o ping novamente obteremos sucesso: $ Execu\u00e7\u00e3o no terminal ansible arch -m ping 10 .0.2.15 | SUCCESS = > { \"ansible_facts\" : { \"discovered_interpreter_python\" : \"/usr/bin/python3.10\" } , \"changed\" : false, \"ping\" : \"pong\" } Isso significa que a comunica\u00e7\u00e3o com os dois n\u00f3s est\u00e1 acontecendo de maneira correta. Mas, faltou entender o que o comando ansible ubuntu -m ping significa: ansible: Chama o ansible ubuntu: O nome do grupo do invent\u00e1rio -m: Significa que vamos chamar um m\u00f3dulo ping: M\u00f3dulo para checar se o grupo est\u00e1 respondendo","title":"Troca de chaves SSH"},{"location":"04_configuracao_do_ansible/#repetindo-o-processo-para-mais-uma-maquina","text":"Agora que j\u00e1 entendemos o que temos que fazer. Podemos adicionar mais uma m\u00e1quina virtual ao nosso ambiente. Vamos criar mais um arch para que seja controlado pelo ansible: Vagrantfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Vagrant . configure ( \"2\" ) do | config | config . vm . define \"main\" do | main | main . vm . box = \"archlinux/archlinux\" end config . vm . define \"ubuntu\" do | ubuntu | ubuntu . vm . box = \"ubuntu/focal64\" end config . vm . define \"arch\" do | arch | arch . vm . box = \"archlinux/archlinux\" end end Agora podemos dar up nessa nova m\u00e1quina: $ Execu\u00e7\u00e3o no terminal exit # caso esteja no conectado no main vagrant up arch Pegamos o endere\u00e7o de ip: $ Execu\u00e7\u00e3o no terminal vagrant ssh arch -c \"ip addr\" 1 : lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00 :00:00:00:00:00 brd 00 :00:00:00:00:00 inet 127 .0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2 : eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08 :00:27:fa:60:9b brd ff:ff:ff:ff:ff:ff altname enp0s3 inet 10.0.2.16 /24 metric 1024 brd 10 .0.2.255 scope global dynamic eth0 valid_lft 86241sec preferred_lft 86241sec inet6 fe80::a00:27ff:fefa:609b/64 scope link valid_lft forever preferred_lft forever Adicionamos esse ip no invent\u00e1rio da m\u00e1quina controladora: /etc/ansible/hosts 1 2 3 4 5 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 Fazemos a troca de chaves SSH, para que o Controlador se comunique de forma segura com o arch : $ Execu\u00e7\u00e3o no terminal ssh-copy-id vagrant@10.0.2.16 # Para copiar a chave de `main` para `arch` Com isso temos dois grupos no n\u00f3 de controle. O ubuntu e o arch . Podemos criar um grupo novo tamb\u00e9m para juntar todos os linux e disparar comandos que funcionem nas duas m\u00e1quinas ao mesmo tempo: /etc/ansible/hosts 1 2 3 4 5 6 7 8 9 [ubuntu] 10.0.2.15 [arch] 10.0.2.16 [linux] 10.0.2.15 10.0.2.16 Dessa forma, podemos chamar o m\u00f3dulo ping para todos os n\u00f3s em um grupo s\u00f3: $ Execu\u00e7\u00e3o no terminal ansible linux -m ping Caso tudo esteja configurado corretamente. Iremos obter sucesso em ambos os pings. O que significa que o comando foi executado com sucesso nas duas m\u00e1quinas.","title":"Repetindo o processo para mais uma m\u00e1quina"},{"location":"04_configuracao_do_ansible/#instalando-um-pacote-em-dois-nos-ao-mesmo-tempo","text":"Vamos iniciar uma configura\u00e7\u00e3o simples e que j\u00e1 rodamos no n\u00f3 controlador. Meu objetivo, por\u00e9m, \u00e9 mostrar a voc\u00eas o poder do ansible de forma simples: $ Execu\u00e7\u00e3o no terminal ansible linux -m package -a \"name=nginx state=present\" -b Dessa forma acabamos de instalar o servidor web Nginx nas nossas duas m\u00e1quinas virtuais ao mesmo tempo. Uma coisa importante de notar e que diferencia de uma forma simpl\u00f3ria de instala\u00e7\u00e3o. \u00c9 que n\u00e3o foi preciso dizer nem ao menos qual o gerenciador de pacotes que \u00e9 usado em cada distribui\u00e7\u00e3o. O m\u00f3dulo package entende isso por padr\u00e3o e usa o gerenciador da distribui\u00e7\u00e3o por baixo dos panos. Com isso, podemos conhecer outro m\u00f3dulo. O m\u00f3dulo do systemd e com ele podemos dizer que queremos dar start no processo do Nginx: $ Execu\u00e7\u00e3o no terminal ansible linux -m systemd -a \"name=nginx state=started\" -b E vol\u00e1, instalamos o Nginx em duas m\u00e1quinas e subimos o server somente usando comandos simples e sem a preocupa\u00e7\u00e3o de ter de entender coisas espec\u00edficas de sistema. Vamos ver se o servi\u00e7o subiu da forma correta? Para isso vou me aproveitar do ansible para instalar o httpie no sistema para fazer essa requisi\u00e7\u00e3o no n\u00f3 controlador. Por\u00e9m, n\u00e3o quero fazer essa instala\u00e7\u00e3o sujando o ambiente. Ent\u00e3o, vamos instalar o pipx $ Execu\u00e7\u00e3o no terminal ansible localhost -m package -a \"name=python-pipx state=present\" -b Agora com o pipx instalado, podemos usar ele via m\u00f3dulo shell para instalar o httpie: $ Execu\u00e7\u00e3o no terminal ansible localhost -m shell -a \"pipx install httpie\" E agora, finalmente, podemos checar se ambos os servi\u00e7os foram startados corretamente pelo ansible: $ Execu\u00e7\u00e3o no terminal http 10 .0.2.15 http 10 .0.2.16 Embora tudo tenha sido executado de forma incr\u00edvel. Ainda considero chato de mais ficar chamando o ansible no terminal o tempo todo. Ent\u00e3o, precisamos de uma forma de melhorar isso.","title":"Instalando um pacote em dois n\u00f3s ao mesmo tempo"},{"location":"05_playbooks/","text":"Playbooks Tudo que executamos at\u00e9 agora foram comandos no terminal com ansible. Voc\u00ea deve estar se perguntando se n\u00e3o seria mais f\u00e1cil criar um script com todos esses comandos, para evitar ter que digitar todas \u00e0s vezes. Para isso existem os playbooks. Voc\u00ea cria um arquivo no formato yaml descrevendo todas as suas tarefas e executa de uma \u00fanica vez. O nome Playbook Playbook \u00e9 uma palavra que se refere a scripts de teatro. Por exemplo, quando algu\u00e9m entra em cena, as falas de cada personagem, etc. No mundo dos esportes, playbook \u00e9 usado muito no beisebol e no basquete. S\u00e3o listas de jogadas que podem ser feitas durante um jogo. Arquivos YAML Arquivos YAML s\u00e3o arquivos geralmente usados para configura\u00e7\u00f5es. Se pensarmos em Python, eles formam estruturas equivalentes a de dicion\u00e1rios. Uma compara\u00e7\u00e3o b\u00e1sica para voc\u00ea entender o formato: YAML Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- chave : valor # valor \u00e9 uma string chave_int : 1 # valor \u00e9 uma int chave_bool : true # valor \u00e9 uma bool uma_lista : - item_0 - item_1 - item_2 um_dict : nome : eduardo idade : 29 # Coment\u00e1rios lista_inline : [ 'item_0' , 'item_1' , 'item_2' ] dict_inline : { 'nome' : 'eduardo' , 'idade' : 29 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"chave\" : \"valor\" , \"chave_int\" : 1 , \"chave_bool\" : true , \"uma_lista\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"um_dict\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 }, \"lista_inline\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"dict_inline\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 } } Nosso primeiro playbook Vamos reproduzir a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Ngix que fizemos via comandos ad-hoc no terminal: web_server.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- - name : Instala\u00e7\u00e3o do nginx hosts : linux # Grupo de hosts do invent\u00e1rio become : yes # Diz que vai escalonar privil\u00e9gios. Equivalente ao -b tasks : # Descri\u00e7\u00e3o das tarefas que ser\u00e3o executadas - name : Instala\u00e7\u00e3o do nginx # Nome da tarefa package : # Nome do m\u00f3dulo # Argumentos do m\u00f3dulo state : present name : nginx - name : Inicializa\u00e7\u00e3o do nginx systemd : state : started name : nginx Dessa forma, no lugar de executar um \u00fanico comando por vez, podemos disparar um playbook que executa diversas tarefas por vez: $ Execu\u00e7\u00e3o no terminal ansible-playbook web_server.yml Voc\u00ea deve ver uma grande resposta como essa: resposta do terminal ansible-playbook web_server.yml PLAY [ Instala\u00e7\u00e3o do nginx ] ***************************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do nginx ] ***************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Inicializa\u00e7\u00e3o do nginx ] ************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ********************************************************************* 10 .0.2.15 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.16 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O que significa que o ansible conseguiu executar o playbook com sucesso. Mais um playbook Sei que voc\u00ea j\u00e1 deve ter captado a ideia do playbook, mas que tal criarmos mais um? Vamos tentar reproduzir a configura\u00e7\u00e3o do emacs no localhost agora. Pois temos outros m\u00f3dulos e outros comandos para aprender: emacs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- - name : Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs hosts : localhost # Aqui mudamos para o localhost tasks : - name : Instala\u00e7\u00e3o do emacs become : yes # Diferente da outra config, somente esse passo ser\u00e1 como root package : state : present name : emacs - name : Instala\u00e7\u00e3o do git become : yes package : name : git state : present - name : Clone do nosso reposit\u00f3rio git : repo : https://github.com/dunossauro/dotfiles.git dest : config_files - name : Movendo os arquivos de configura\u00e7\u00e3o do emacs copy : dest : /home/vagrant/ src : /home/vagrant/config_files/.emacs.d Se executarmos esse playbook podemos ver algumas mensagens diferentes na resposta: $ Execu\u00e7\u00e3o no terminal ansible-playbook emacs.yml A resposta: resposta do terminal PLAY [ Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs ] ************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do emacs ] ***************************************************** ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do git ] ******************************************************* ok: [ localhost ] TASK [ Clone do nosso reposit\u00f3rio ] ********************************************** changed : [ localhost ] TASK [ Movendo os arquivos de configura\u00e7\u00e3o do emacs ] **************************** changed : [ localhost ] PLAY RECAP ********************************************************************* localhost : ok = 5 changed = 2 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O status changed apareceu. Significa que o resultado desse comando foi diferente da primeira vez que foi executado. O que quer dizer que alguma coisa mudou desde a \u00faltima execu\u00e7\u00e3o. Provavelmente a resposta do ansible foi diferente, pois o clone n\u00e3o foi feito, o diret\u00f3rio j\u00e1 existia e o move tamb\u00e9m j\u00e1 tinha sido feito antes. Condicionais Vamos recapitular mais uma coisa que j\u00e1 instalamos no nosso ambiente. O pipx e o httpie . N\u00e3o s\u00e3o pacotes t\u00e3o relevantes para o andamento do tutorial, mas precisamos aprender coisas legais com ansible antes de fazer coisas realmente \u00fateis. O pacote do pipx existe no reposit\u00f3rio do archlinux como j\u00e1 vimos. O pacote se chama python-pipx . Vamos iniciar um playbook para essa instala\u00e7\u00e3o e ver os problemas que vamos encontrar no caminho: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux # vale lembrar aqui que um dos linux \u00e9 o arch e o outro o ubuntu tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : python-pipx state : present Vamos executar para ver o que conseguimos com isso: $ Execu\u00e7\u00e3o no terminal ansible-playbook pipx_httpie.yml Obteremos a seguinte resposta: PLAY [Instala\u00e7\u00e3o do pipx e httpie] ********************************************* TASK [Gathering Facts] ********************************************************* ok: [10.0.2.15] ok: [10.0.2.16] TASK [Instala\u00e7\u00e3o do pipx] ****************************************************** fatal: [10.0.2.15]: FAILED! => {\"changed\": false, \"msg\": \"No package matching 'python-pipx' is available\"} changed: [10.0.2.16] PLAY RECAP ********************************************************************* 10.0.2.15 : ok=1 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0 10.0.2.16 : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 Repare na linha destacada. A m\u00e1quina associada ao ip 10.2.2.15 n\u00e3o tem um pacote no reposit\u00f3rio chamado python-pipx . Esse foi o motivo da falha. O pacote existe no reposit\u00f3rio do arch, por\u00e9m n\u00e3o existe no reposit\u00f3rio do ubuntu. Para resolver esse problema precisamos descobrir o nome do pacote no reposit\u00f3rio do ubuntu . E para saber isso precisamos saber qual a vers\u00e3o do ubuntu estamos usando. Voc\u00ea deve se lembrar que escrever no Vagrantfile ubuntu/focal64 . Ent\u00e3o, sabemos que a vers\u00e3o \u00e9 a focal . Por\u00e9m, se n\u00e3o soub\u00e9ssemos essa informa\u00e7\u00e3o. Como o ansible poderia nos ajudar a descobrir? O m\u00f3dulo setup O Ansible conta com um m\u00f3dulo chamado setup . Esse m\u00f3dulo pode ser chamado via ad-hoc, mas tamb\u00e9m \u00e9 a base para algumas vari\u00e1veis nos playbooks. Primeiro vamos executar via ad-hoc: $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m setup Esse comando nos retornar\u00e1 uma resposta MUITO extensa. Que acabei deixando em um arquivo separado. Voc\u00ea pode acessar aqui . Vamos destacar somente algumas coisas que fazem sentido para nosso passo atual: 344 345 346 347 348 349 350 \"ansible_distribution\" : \"Ubuntu\" , \"ansible_distribution_file_parsed\" : true , \"ansible_distribution_file_path\" : \"/etc/os-release\" , \"ansible_distribution_file_variety\" : \"Debian\" , \"ansible_distribution_major_version\" : \"20\" , \"ansible_distribution_release\" : \"focal\" , \"ansible_distribution_version\" : \"20.04\" , Podemos ver que o ansible sabe qual a distribui\u00e7\u00e3o que est\u00e1 sendo usada Ubuntu , qual a vers\u00e3o do sistema 20.04 e a release que est\u00e1 sendo executada focal . O setup consegue mostrar diversos outros dados. Sobre as interfaces de rede, sobre mem\u00f3ria, etc. Aproveitando que j\u00e1 estamos vendo o m\u00f3dulo setup , podemos usar a fun\u00e7\u00e3o de filtro do m\u00f3dulo para exibir somente as informa\u00e7\u00f5es que precisamos. Qualquer coisa que comece com ansible_distribution : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m setup -a \"filter=ansible_distribution*\" Que nos retornar\u00e1 os mesmos dados que destaquei: 10.0.2.15 | SUCCESS => { \"ansible_facts\": { \"ansible_distribution\": \"Ubuntu\", \"ansible_distribution_file_parsed\": true, \"ansible_distribution_file_path\": \"/etc/os-release\", \"ansible_distribution_file_variety\": \"Debian\", \"ansible_distribution_major_version\": \"20\", \"ansible_distribution_release\": \"focal\", \"ansible_distribution_version\": \"20.04\", \"discovered_interpreter_python\": \"/usr/bin/python3\" }, \"changed\": false } Agora que sabemos que \u00e9 o Ubuntu Focal, podemos voltar ao reposit\u00f3rio. O pacote existe, por\u00e9m, com outro nome pipx . A clausula when Como disse, as vari\u00e1veis do setup podem ser invocadas dentro do playbook. Dessa forma podemos criar valida\u00e7\u00f5es condicionais no nosso playbook. Vamos criar uma restri\u00e7\u00e3o para que a task seja executada somente no arch linux: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 11 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux # vale lembrar aqui que um dos linux \u00e9 o arch e o outro o ubuntu tasks : - name : Instala\u00e7\u00e3o do pipx no Arch become : yes package : name : python-pipx state : present when : ansible_distribution == Archlinux' As linhas destacadas mostra somente as altera\u00e7\u00f5es que fizemos no playbook. Dessa forma, a task Instala\u00e7\u00e3o do pipx no Arch s\u00f3 ser\u00e1 executada quando a distribui\u00e7\u00e3o for Archlinux . Vamos testar: $ Execu\u00e7\u00e3o no terminal ansible-playbook pipx_httpie.yml Resultado do shell PLAY [ Instala\u00e7\u00e3o do pipx e httpie ] ******************************************************** TASK [ Gathering Facts ] ******************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* skipping: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ******************************************************************************** 10 .0.2.16 : ok = 2 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.15 : ok = 1 changed = 0 unreachable = 0 failed = 0 skipped = 1 rescued = 0 ignored = 0 Com isso, podemos ver o status skipped . Isso quer dizer que o passo de instalar no arch, quando passou pela instala\u00e7\u00e3o no ubuntu \"pulou\" esse passo. Sabendo disso, podemos criar uma nova task espec\u00edfica para o ubuntu que pule no arch tamb\u00e9m: pipx_httpie.yml 13 14 15 16 17 18 - name : Instala\u00e7\u00e3o do pipx no Ubuntu become : yes package : name : pipx state : present when : ansible_distribution == 'Ubuntu' Dessa forma, quando executarmos o playbook teremos certeza que a execu\u00e7\u00e3o vai acontecer nos dois n\u00f3s. Mesmo que em tasks diferentes. $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* skipping: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do pipx no Ubuntu ] ******************************************************* skipping: [ 10 .0.2.16 ] ok: [ 10 .0.2.15 ] Desta forma n\u00e3o precisamos mais nos preocupar com os pacotes espec\u00edficos de cada sistema, podemos criar uma task para cada sistema. Em casos extremos isso pode ser necess\u00e1rio. Mas ser\u00e1 que n\u00e3o existe uma forma mais simples de resolver esse problema? Express\u00f5es e vari\u00e1veis Quando chamamos o setup, vimos que o ansible consegue carregar diversas vari\u00e1veis durante a execu\u00e7\u00e3o. Mas ser\u00e1 que nesse caso n\u00e3o conseguir\u00edamos criar uma vari\u00e1vel nossa? A\u00ed poder\u00edamos validar antes e evitar escrever duas tasks. Express\u00f5es O Ansible usa um motor de templates chamado Jinja . O jinja fornece uma forma de chamar express\u00f5es de c\u00f3digo Python dentro de templates. Assim, quando o ansible executa um playbook ele tamb\u00e9m avalia e executa as express\u00f5es do jinja dentro do c\u00f3digo. As express\u00f5es no jinja s\u00e3o feitas usando duas chaves delimitador {{ minha_express\u00e3o }} . E dentre dessa express\u00e3o, qualquer c\u00f3digo python pode ser inserido. Por exemplo, podemos fazer um if para resolver nosso caso e ter uma \u00fanica task. Por exemplo: pipx_httpie.yml 5 6 7 8 9 10 tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" state : present Nota sobre express\u00f5es no Asnbile Embora para o jinja somente precise ser usado {{ express\u00e3o }} . O Ansible exige que esses blocos estejam tamb\u00e9m entre aspas. Ficando '{{ express\u00e3o }}' . Desta forma acabamos resolvendo o problema que t\u00ednhamos em ter duas tasks para executar a mesma tarefa em sistemas diferentes. Vamos ver o resultado: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] Assim podemos ser mais eficientes em criar regras. J\u00e1 o que template pode estender c\u00f3digo python. As vari\u00e1veis no ansible Da mesma forma que podemos criar express\u00f5es complexas no jinja. Tamb\u00e9m podemos chamar somente vari\u00e1veis. Por exemplo, \"{{ variavel }}\" . Assim podemos declarar as express\u00f5es em um lugar espec\u00edfico do playbook para deixar mais limpo ou passar as mesmas via linha de comando. Vari\u00e1veis no playbook Para isso, podemos trocar o nome do pacote do pipx no playbook para uma vari\u00e1vel: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux vars : pipx : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : '{{ pipx }}' state : present Assim temos um playbook mais limpo. Pois todo o c\u00f3digo complicado do jinja fica em um lugar espec\u00edfico e no topo do arquivo para ficar f\u00e1cil a consulta. N\u00e3o vou executar esse playbook agora, pois teremos o mesmo resultado da execu\u00e7\u00e3o anterior. Vari\u00e1veis via linha de comando Outra funcionalidade importante do ansible \u00e9 conseguir sobrescrever as vari\u00e1veis de um playbook usando a linha de comando como base. Chamar via linha de comando tem uma ordem de preced\u00eancia maior que as vari\u00e1veis definidas no playbook. Ent\u00e3o, quando o ansible for chamado, as vari\u00e1veis definidas no campo vars ser\u00e3o substitu\u00eddas pelas vari\u00e1veis que forem passadas na linha de comando: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml --extra-vars \"pipx=pipx\" TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] fatal: [ 10 .0.2.16 ] : FAILED! = > { \"changed\" : false, \"cmd\" : [ \"/usr/bin/pacman\" , \"--upgrade\" , \"--print-format\" , \"%n\" , \"pipx\" ] , \"msg\" : \"Failed to list package pipx\" , \"rc\" : 1 , \"stderr\" : \"error: 'pipx': could not find or read package\\n\" , \"stderr_lines\" : [ \"error: 'pipx': could not find or read package\" ] , \"stdout\" : \"loading packages...\\n\" , \"stdout_lines\" : [ \"loading packages...\" ]} Como era de se esperar, o pacote pipx n\u00e3o existe no arch, seu nome \u00e9 python-pipx por conta disso, o comando n\u00e3o foi executado com sucesso. Nosso objetivo, por\u00e9m, era explorar a chamada de vari\u00e1veis via linha de comando. Arquivos de vari\u00e1veis Uma forma de evitar express\u00f5es do jinja e tamb\u00e9m chamar vari\u00e1veis por linha de comando \u00e9 criar um arquivo s\u00f3 para as vari\u00e1veis. Dessa forma, caso tenha alguma vari\u00e1vel que n\u00e3o possa ser exposta, como endere\u00e7o de um banco de dados. Esses valores ficam de fora da configura\u00e7\u00e3o. variaveis.yml 1 2 --- pipx : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" Dessa forma podemos limpar o nosso arquivo pipx_httpie.yml : pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : '{{ pipx }}' state : present E quando formos executar o playbook, s\u00f3 precisamos passar o arquivo de configura\u00e7\u00e3o para as vari\u00e1veis: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml -e @variaveis.yml TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] Assim demos uma limpada no nosso arquivo de playbook e claro, podemos definir diversas outras vari\u00e1veis no arquivo. Mas, voc\u00ea pode tentar depois Arquivos de vari\u00e1veis por grupo Outra coisa que pode facilitar na hora de usar as vari\u00e1veis \u00e9 criar vari\u00e1veis espec\u00edficas para grupos. O ansible tem um caminho espec\u00edfico para onde esses arquivos de vari\u00e1veis devem ser colocados: /etc/ansible/group_vars/ . Para resolver isso, vamos criar um grupo de vari\u00e1veis para o ubuntu: /etc/ansible/group_vars/ubuntu.yml 1 2 --- pipx : pipx e um arquivo para o arch: /etc/ansible/group_vars/arch.yml 1 2 --- pipx : python-pipx Dessa forma, quando formos executar o playbook n\u00e3o precisamos mais especificar as vari\u00e1veis comuns. Cada sistema tem sua vers\u00e3o de pipx conforme os grupos do invent\u00e1rio: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ]","title":"Playbooks"},{"location":"05_playbooks/#playbooks","text":"Tudo que executamos at\u00e9 agora foram comandos no terminal com ansible. Voc\u00ea deve estar se perguntando se n\u00e3o seria mais f\u00e1cil criar um script com todos esses comandos, para evitar ter que digitar todas \u00e0s vezes. Para isso existem os playbooks. Voc\u00ea cria um arquivo no formato yaml descrevendo todas as suas tarefas e executa de uma \u00fanica vez. O nome Playbook Playbook \u00e9 uma palavra que se refere a scripts de teatro. Por exemplo, quando algu\u00e9m entra em cena, as falas de cada personagem, etc. No mundo dos esportes, playbook \u00e9 usado muito no beisebol e no basquete. S\u00e3o listas de jogadas que podem ser feitas durante um jogo.","title":"Playbooks"},{"location":"05_playbooks/#arquivos-yaml","text":"Arquivos YAML s\u00e3o arquivos geralmente usados para configura\u00e7\u00f5es. Se pensarmos em Python, eles formam estruturas equivalentes a de dicion\u00e1rios. Uma compara\u00e7\u00e3o b\u00e1sica para voc\u00ea entender o formato: YAML Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --- chave : valor # valor \u00e9 uma string chave_int : 1 # valor \u00e9 uma int chave_bool : true # valor \u00e9 uma bool uma_lista : - item_0 - item_1 - item_2 um_dict : nome : eduardo idade : 29 # Coment\u00e1rios lista_inline : [ 'item_0' , 'item_1' , 'item_2' ] dict_inline : { 'nome' : 'eduardo' , 'idade' : 29 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \"chave\" : \"valor\" , \"chave_int\" : 1 , \"chave_bool\" : true , \"uma_lista\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"um_dict\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 }, \"lista_inline\" : [ \"item_0\" , \"item_1\" , \"item_2\" ], \"dict_inline\" : { \"nome\" : \"eduardo\" , \"idade\" : 29 } }","title":"Arquivos YAML"},{"location":"05_playbooks/#nosso-primeiro-playbook","text":"Vamos reproduzir a instala\u00e7\u00e3o e configura\u00e7\u00e3o do Ngix que fizemos via comandos ad-hoc no terminal: web_server.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- - name : Instala\u00e7\u00e3o do nginx hosts : linux # Grupo de hosts do invent\u00e1rio become : yes # Diz que vai escalonar privil\u00e9gios. Equivalente ao -b tasks : # Descri\u00e7\u00e3o das tarefas que ser\u00e3o executadas - name : Instala\u00e7\u00e3o do nginx # Nome da tarefa package : # Nome do m\u00f3dulo # Argumentos do m\u00f3dulo state : present name : nginx - name : Inicializa\u00e7\u00e3o do nginx systemd : state : started name : nginx Dessa forma, no lugar de executar um \u00fanico comando por vez, podemos disparar um playbook que executa diversas tarefas por vez: $ Execu\u00e7\u00e3o no terminal ansible-playbook web_server.yml Voc\u00ea deve ver uma grande resposta como essa: resposta do terminal ansible-playbook web_server.yml PLAY [ Instala\u00e7\u00e3o do nginx ] ***************************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do nginx ] ***************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Inicializa\u00e7\u00e3o do nginx ] ************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ********************************************************************* 10 .0.2.15 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.16 : ok = 3 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O que significa que o ansible conseguiu executar o playbook com sucesso.","title":"Nosso primeiro playbook"},{"location":"05_playbooks/#mais-um-playbook","text":"Sei que voc\u00ea j\u00e1 deve ter captado a ideia do playbook, mas que tal criarmos mais um? Vamos tentar reproduzir a configura\u00e7\u00e3o do emacs no localhost agora. Pois temos outros m\u00f3dulos e outros comandos para aprender: emacs.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- - name : Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs hosts : localhost # Aqui mudamos para o localhost tasks : - name : Instala\u00e7\u00e3o do emacs become : yes # Diferente da outra config, somente esse passo ser\u00e1 como root package : state : present name : emacs - name : Instala\u00e7\u00e3o do git become : yes package : name : git state : present - name : Clone do nosso reposit\u00f3rio git : repo : https://github.com/dunossauro/dotfiles.git dest : config_files - name : Movendo os arquivos de configura\u00e7\u00e3o do emacs copy : dest : /home/vagrant/ src : /home/vagrant/config_files/.emacs.d Se executarmos esse playbook podemos ver algumas mensagens diferentes na resposta: $ Execu\u00e7\u00e3o no terminal ansible-playbook emacs.yml A resposta: resposta do terminal PLAY [ Instala\u00e7\u00e3o e configura\u00e7\u00e3o do emacs ] ************************************** TASK [ Gathering Facts ] ********************************************************* ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do emacs ] ***************************************************** ok: [ localhost ] TASK [ Instala\u00e7\u00e3o do git ] ******************************************************* ok: [ localhost ] TASK [ Clone do nosso reposit\u00f3rio ] ********************************************** changed : [ localhost ] TASK [ Movendo os arquivos de configura\u00e7\u00e3o do emacs ] **************************** changed : [ localhost ] PLAY RECAP ********************************************************************* localhost : ok = 5 changed = 2 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 O status changed apareceu. Significa que o resultado desse comando foi diferente da primeira vez que foi executado. O que quer dizer que alguma coisa mudou desde a \u00faltima execu\u00e7\u00e3o. Provavelmente a resposta do ansible foi diferente, pois o clone n\u00e3o foi feito, o diret\u00f3rio j\u00e1 existia e o move tamb\u00e9m j\u00e1 tinha sido feito antes.","title":"Mais um playbook"},{"location":"05_playbooks/#condicionais","text":"Vamos recapitular mais uma coisa que j\u00e1 instalamos no nosso ambiente. O pipx e o httpie . N\u00e3o s\u00e3o pacotes t\u00e3o relevantes para o andamento do tutorial, mas precisamos aprender coisas legais com ansible antes de fazer coisas realmente \u00fateis. O pacote do pipx existe no reposit\u00f3rio do archlinux como j\u00e1 vimos. O pacote se chama python-pipx . Vamos iniciar um playbook para essa instala\u00e7\u00e3o e ver os problemas que vamos encontrar no caminho: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux # vale lembrar aqui que um dos linux \u00e9 o arch e o outro o ubuntu tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : python-pipx state : present Vamos executar para ver o que conseguimos com isso: $ Execu\u00e7\u00e3o no terminal ansible-playbook pipx_httpie.yml Obteremos a seguinte resposta: PLAY [Instala\u00e7\u00e3o do pipx e httpie] ********************************************* TASK [Gathering Facts] ********************************************************* ok: [10.0.2.15] ok: [10.0.2.16] TASK [Instala\u00e7\u00e3o do pipx] ****************************************************** fatal: [10.0.2.15]: FAILED! => {\"changed\": false, \"msg\": \"No package matching 'python-pipx' is available\"} changed: [10.0.2.16] PLAY RECAP ********************************************************************* 10.0.2.15 : ok=1 changed=0 unreachable=0 failed=1 skipped=0 rescued=0 ignored=0 10.0.2.16 : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 Repare na linha destacada. A m\u00e1quina associada ao ip 10.2.2.15 n\u00e3o tem um pacote no reposit\u00f3rio chamado python-pipx . Esse foi o motivo da falha. O pacote existe no reposit\u00f3rio do arch, por\u00e9m n\u00e3o existe no reposit\u00f3rio do ubuntu. Para resolver esse problema precisamos descobrir o nome do pacote no reposit\u00f3rio do ubuntu . E para saber isso precisamos saber qual a vers\u00e3o do ubuntu estamos usando. Voc\u00ea deve se lembrar que escrever no Vagrantfile ubuntu/focal64 . Ent\u00e3o, sabemos que a vers\u00e3o \u00e9 a focal . Por\u00e9m, se n\u00e3o soub\u00e9ssemos essa informa\u00e7\u00e3o. Como o ansible poderia nos ajudar a descobrir?","title":"Condicionais"},{"location":"05_playbooks/#o-modulo-setup","text":"O Ansible conta com um m\u00f3dulo chamado setup . Esse m\u00f3dulo pode ser chamado via ad-hoc, mas tamb\u00e9m \u00e9 a base para algumas vari\u00e1veis nos playbooks. Primeiro vamos executar via ad-hoc: $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m setup Esse comando nos retornar\u00e1 uma resposta MUITO extensa. Que acabei deixando em um arquivo separado. Voc\u00ea pode acessar aqui . Vamos destacar somente algumas coisas que fazem sentido para nosso passo atual: 344 345 346 347 348 349 350 \"ansible_distribution\" : \"Ubuntu\" , \"ansible_distribution_file_parsed\" : true , \"ansible_distribution_file_path\" : \"/etc/os-release\" , \"ansible_distribution_file_variety\" : \"Debian\" , \"ansible_distribution_major_version\" : \"20\" , \"ansible_distribution_release\" : \"focal\" , \"ansible_distribution_version\" : \"20.04\" , Podemos ver que o ansible sabe qual a distribui\u00e7\u00e3o que est\u00e1 sendo usada Ubuntu , qual a vers\u00e3o do sistema 20.04 e a release que est\u00e1 sendo executada focal . O setup consegue mostrar diversos outros dados. Sobre as interfaces de rede, sobre mem\u00f3ria, etc. Aproveitando que j\u00e1 estamos vendo o m\u00f3dulo setup , podemos usar a fun\u00e7\u00e3o de filtro do m\u00f3dulo para exibir somente as informa\u00e7\u00f5es que precisamos. Qualquer coisa que comece com ansible_distribution : $ Execu\u00e7\u00e3o no terminal ansible ubuntu -m setup -a \"filter=ansible_distribution*\" Que nos retornar\u00e1 os mesmos dados que destaquei: 10.0.2.15 | SUCCESS => { \"ansible_facts\": { \"ansible_distribution\": \"Ubuntu\", \"ansible_distribution_file_parsed\": true, \"ansible_distribution_file_path\": \"/etc/os-release\", \"ansible_distribution_file_variety\": \"Debian\", \"ansible_distribution_major_version\": \"20\", \"ansible_distribution_release\": \"focal\", \"ansible_distribution_version\": \"20.04\", \"discovered_interpreter_python\": \"/usr/bin/python3\" }, \"changed\": false } Agora que sabemos que \u00e9 o Ubuntu Focal, podemos voltar ao reposit\u00f3rio. O pacote existe, por\u00e9m, com outro nome pipx .","title":"O m\u00f3dulo setup"},{"location":"05_playbooks/#a-clausula-when","text":"Como disse, as vari\u00e1veis do setup podem ser invocadas dentro do playbook. Dessa forma podemos criar valida\u00e7\u00f5es condicionais no nosso playbook. Vamos criar uma restri\u00e7\u00e3o para que a task seja executada somente no arch linux: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 11 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux # vale lembrar aqui que um dos linux \u00e9 o arch e o outro o ubuntu tasks : - name : Instala\u00e7\u00e3o do pipx no Arch become : yes package : name : python-pipx state : present when : ansible_distribution == Archlinux' As linhas destacadas mostra somente as altera\u00e7\u00f5es que fizemos no playbook. Dessa forma, a task Instala\u00e7\u00e3o do pipx no Arch s\u00f3 ser\u00e1 executada quando a distribui\u00e7\u00e3o for Archlinux . Vamos testar: $ Execu\u00e7\u00e3o no terminal ansible-playbook pipx_httpie.yml Resultado do shell PLAY [ Instala\u00e7\u00e3o do pipx e httpie ] ******************************************************** TASK [ Gathering Facts ] ******************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* skipping: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] PLAY RECAP ******************************************************************************** 10 .0.2.16 : ok = 2 changed = 0 unreachable = 0 failed = 0 skipped = 0 rescued = 0 ignored = 0 10 .0.2.15 : ok = 1 changed = 0 unreachable = 0 failed = 0 skipped = 1 rescued = 0 ignored = 0 Com isso, podemos ver o status skipped . Isso quer dizer que o passo de instalar no arch, quando passou pela instala\u00e7\u00e3o no ubuntu \"pulou\" esse passo. Sabendo disso, podemos criar uma nova task espec\u00edfica para o ubuntu que pule no arch tamb\u00e9m: pipx_httpie.yml 13 14 15 16 17 18 - name : Instala\u00e7\u00e3o do pipx no Ubuntu become : yes package : name : pipx state : present when : ansible_distribution == 'Ubuntu' Dessa forma, quando executarmos o playbook teremos certeza que a execu\u00e7\u00e3o vai acontecer nos dois n\u00f3s. Mesmo que em tasks diferentes. $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* skipping: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] TASK [ Instala\u00e7\u00e3o do pipx no Ubuntu ] ******************************************************* skipping: [ 10 .0.2.16 ] ok: [ 10 .0.2.15 ] Desta forma n\u00e3o precisamos mais nos preocupar com os pacotes espec\u00edficos de cada sistema, podemos criar uma task para cada sistema. Em casos extremos isso pode ser necess\u00e1rio. Mas ser\u00e1 que n\u00e3o existe uma forma mais simples de resolver esse problema?","title":"A clausula when"},{"location":"05_playbooks/#expressoes-e-variaveis","text":"Quando chamamos o setup, vimos que o ansible consegue carregar diversas vari\u00e1veis durante a execu\u00e7\u00e3o. Mas ser\u00e1 que nesse caso n\u00e3o conseguir\u00edamos criar uma vari\u00e1vel nossa? A\u00ed poder\u00edamos validar antes e evitar escrever duas tasks.","title":"Express\u00f5es e vari\u00e1veis"},{"location":"05_playbooks/#expressoes","text":"O Ansible usa um motor de templates chamado Jinja . O jinja fornece uma forma de chamar express\u00f5es de c\u00f3digo Python dentro de templates. Assim, quando o ansible executa um playbook ele tamb\u00e9m avalia e executa as express\u00f5es do jinja dentro do c\u00f3digo. As express\u00f5es no jinja s\u00e3o feitas usando duas chaves delimitador {{ minha_express\u00e3o }} . E dentre dessa express\u00e3o, qualquer c\u00f3digo python pode ser inserido. Por exemplo, podemos fazer um if para resolver nosso caso e ter uma \u00fanica task. Por exemplo: pipx_httpie.yml 5 6 7 8 9 10 tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" state : present Nota sobre express\u00f5es no Asnbile Embora para o jinja somente precise ser usado {{ express\u00e3o }} . O Ansible exige que esses blocos estejam tamb\u00e9m entre aspas. Ficando '{{ express\u00e3o }}' . Desta forma acabamos resolvendo o problema que t\u00ednhamos em ter duas tasks para executar a mesma tarefa em sistemas diferentes. Vamos ver o resultado: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx no Arch ] ********************************************************* ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] Assim podemos ser mais eficientes em criar regras. J\u00e1 o que template pode estender c\u00f3digo python.","title":"Express\u00f5es"},{"location":"05_playbooks/#as-variaveis-no-ansible","text":"Da mesma forma que podemos criar express\u00f5es complexas no jinja. Tamb\u00e9m podemos chamar somente vari\u00e1veis. Por exemplo, \"{{ variavel }}\" . Assim podemos declarar as express\u00f5es em um lugar espec\u00edfico do playbook para deixar mais limpo ou passar as mesmas via linha de comando.","title":"As vari\u00e1veis no ansible"},{"location":"05_playbooks/#variaveis-no-playbook","text":"Para isso, podemos trocar o nome do pacote do pipx no playbook para uma vari\u00e1vel: pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux vars : pipx : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : '{{ pipx }}' state : present Assim temos um playbook mais limpo. Pois todo o c\u00f3digo complicado do jinja fica em um lugar espec\u00edfico e no topo do arquivo para ficar f\u00e1cil a consulta. N\u00e3o vou executar esse playbook agora, pois teremos o mesmo resultado da execu\u00e7\u00e3o anterior.","title":"Vari\u00e1veis no playbook"},{"location":"05_playbooks/#variaveis-via-linha-de-comando","text":"Outra funcionalidade importante do ansible \u00e9 conseguir sobrescrever as vari\u00e1veis de um playbook usando a linha de comando como base. Chamar via linha de comando tem uma ordem de preced\u00eancia maior que as vari\u00e1veis definidas no playbook. Ent\u00e3o, quando o ansible for chamado, as vari\u00e1veis definidas no campo vars ser\u00e3o substitu\u00eddas pelas vari\u00e1veis que forem passadas na linha de comando: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml --extra-vars \"pipx=pipx\" TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] fatal: [ 10 .0.2.16 ] : FAILED! = > { \"changed\" : false, \"cmd\" : [ \"/usr/bin/pacman\" , \"--upgrade\" , \"--print-format\" , \"%n\" , \"pipx\" ] , \"msg\" : \"Failed to list package pipx\" , \"rc\" : 1 , \"stderr\" : \"error: 'pipx': could not find or read package\\n\" , \"stderr_lines\" : [ \"error: 'pipx': could not find or read package\" ] , \"stdout\" : \"loading packages...\\n\" , \"stdout_lines\" : [ \"loading packages...\" ]} Como era de se esperar, o pacote pipx n\u00e3o existe no arch, seu nome \u00e9 python-pipx por conta disso, o comando n\u00e3o foi executado com sucesso. Nosso objetivo, por\u00e9m, era explorar a chamada de vari\u00e1veis via linha de comando.","title":"Vari\u00e1veis via linha de comando"},{"location":"05_playbooks/#arquivos-de-variaveis","text":"Uma forma de evitar express\u00f5es do jinja e tamb\u00e9m chamar vari\u00e1veis por linha de comando \u00e9 criar um arquivo s\u00f3 para as vari\u00e1veis. Dessa forma, caso tenha alguma vari\u00e1vel que n\u00e3o possa ser exposta, como endere\u00e7o de um banco de dados. Esses valores ficam de fora da configura\u00e7\u00e3o. variaveis.yml 1 2 --- pipx : \"{{ 'pipx' if ansible_distribution == 'Ubuntu' else 'python-pipx'}}\" Dessa forma podemos limpar o nosso arquivo pipx_httpie.yml : pipx_httpie.yml 1 2 3 4 5 6 7 8 9 10 --- - name : Instala\u00e7\u00e3o do pipx e httpie hosts : linux tasks : - name : Instala\u00e7\u00e3o do pipx become : yes package : name : '{{ pipx }}' state : present E quando formos executar o playbook, s\u00f3 precisamos passar o arquivo de configura\u00e7\u00e3o para as vari\u00e1veis: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml -e @variaveis.yml TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ] Assim demos uma limpada no nosso arquivo de playbook e claro, podemos definir diversas outras vari\u00e1veis no arquivo. Mas, voc\u00ea pode tentar depois","title":"Arquivos de vari\u00e1veis"},{"location":"05_playbooks/#arquivos-de-variaveis-por-grupo","text":"Outra coisa que pode facilitar na hora de usar as vari\u00e1veis \u00e9 criar vari\u00e1veis espec\u00edficas para grupos. O ansible tem um caminho espec\u00edfico para onde esses arquivos de vari\u00e1veis devem ser colocados: /etc/ansible/group_vars/ . Para resolver isso, vamos criar um grupo de vari\u00e1veis para o ubuntu: /etc/ansible/group_vars/ubuntu.yml 1 2 --- pipx : pipx e um arquivo para o arch: /etc/ansible/group_vars/arch.yml 1 2 --- pipx : python-pipx Dessa forma, quando formos executar o playbook n\u00e3o precisamos mais especificar as vari\u00e1veis comuns. Cada sistema tem sua vers\u00e3o de pipx conforme os grupos do invent\u00e1rio: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook pipx_httpie.yml TASK [ Instala\u00e7\u00e3o do pipx ] ***************************************************************** ok: [ 10 .0.2.15 ] ok: [ 10 .0.2.16 ]","title":"Arquivos de vari\u00e1veis por grupo"},{"location":"06_tasks/","text":"Tasks Embora tenhamos usados tasks em praticamente tudo at\u00e9 aqui. Acredito que valha um momento espec\u00edfico para falar sobre elas. Pois nem sempre as coisas d\u00e3o certo e \u00e0s vezes precisamos debugar as tarefas no Ansible. Ent\u00e3o nessa parte vamos falar um pouco sobre tasks, um pouco sobre debug e um pouco sobre agrupamento de tasks. Uma task qualquer Para exemplificar uma task, quero fazer com voc\u00eas a instala\u00e7\u00e3o do pyenv. Costuma dar bastante problema, pois o SSH usado pelo Ansible n\u00e3o consegue reconhecer o .bashrc Para come\u00e7ar, vamos instalar o git e fazer o clone do pyenv: config_python.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- - name : Configura\u00e7\u00e3o do ambiente python hosts : linux tasks : - name : Install git become : yes package : name : git state : present - name : Clone Pyenv git : repo : https://github.com/pyenv/pyenv.git dest : ~/.pyenv Por\u00e9m, a configura\u00e7\u00e3o do pyenv depende de que o arquivo ./bashrc seja modificado para que o pyenv funcione de fato. Ent\u00e3o agora vamos aprender mais um m\u00f3dulo. O m\u00f3dulo blockinfile . Ele permite que adicionemos um bloco de texto em um arquivo qualquer: config_python.yml 17 18 19 20 21 22 23 24 - name : config pyenv blockinfile : dest : ~/.bashrc block : | echo 'export PATH=\"$HOME/.pyenv/bin:$PATH\"' >> ~/.bashrc echo 'eval \"$(pyenv init -)\"' >>~/.bashrc echo 'eval \"$(pyenv virtualenv-init -)\"' >> ~/.bashrc echo 'PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc Register Vamos supor que queremos checar o que est\u00e1 escrito dentro do arquivo .bashrc para saber se ele est\u00e1 escrito da maneira correta. Para isso vamos criar mais uma task. Para isso vamos usar o m\u00f3dulo shell e tamb\u00e9m a funcionalidade de registro em vari\u00e1veis do ansible: config_python.yml 27 28 29 - name : Show bashrc shell : cat ~/.bashrc register : bashrc Dessa forma, por termos chamado register o ansible vai armazenar o resultado da tarefa Show bashrc na vari\u00e1vel bashrc . E podemos acessar ela usando o m\u00f3dulo de debug : config_python.yml 30 31 32 - name : Checking bashrc debug : msg : \"{{ bashrc.stdout.split('\\n') }}\" Quando o playbook for executado, nos mostrar\u00e1 de maneira formatada o stdout da tarefa Show bashrc : $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook config_python.yml TASK [ Show bashrc ] ******************************************************************************* changed: [ IP ] TASK [ Checking bashrc ] ******************************************************************** ok: [ IP ] = > { \"msg\" : [ \"#\" , \"# ~/.bashrc\" , \"#\" , \"\" , \"# If not running interactively, don't do anything\" , \"[[ $- != *i* ]] && return\" , \"\" , \"alias ls='ls --color=auto'\" , \"PS1='[\\\\u@\\\\h \\\\W]\\\\ $ '\" , \"# BEGIN ANSIBLE MANAGED BLOCK\" , \"echo 'export PATH=\\\" $HOME /.pyenv/bin: $PATH \\\"' >> ~/.bashrc\" , \"echo 'eval \\\" $( pyenv init - ) \\\"' >>~/.bashrc\" , \"echo 'eval \\\" $( pyenv virtualenv-init - ) \\\"' >> ~/.bashrc\" , \"echo 'PATH=\\\" $HOME /.local/bin: $PATH \\\"' >> ~/.bashrc\" , \"# END ANSIBLE MANAGED BLOCK\" ] } O que significa que conseguimos chamar o debug. Por\u00e9m, em alguns momentos as tasks podem e v\u00e3o dar errado. Ent\u00e3o precisamos entender como prosseguir, caso isso aconte\u00e7a. Debug de tasks Vamos executar uma a\u00e7\u00e3o que tenho certeza que vai dar erro por conta das configura\u00e7\u00f5es que fizemos at\u00e9 agora para entender como podemos checar as mensagens de erro. Em teoria, se temos o pyenv instalado, podemos pedir para que ele instale a vers\u00e3o 3.11 do python: config_python.yml 34 35 36 37 - block : - name : install python3.11 shell : pyenv install -s 3.11:latest register : pyenv_result Note que inseri um bloco no playbook chamado block . Ele nos ajuda a executar uma tarefa na sequ\u00eancia caso uma delas d\u00ea erro. E para isso vamos adicionar um par\u00e2metro para esse bloco chamado rescue . Ficando com esse bloco: config_python.yml 34 35 36 37 38 39 40 41 42 - block : - name : install python3.11 shell : pyenv install -s 3.11:latest register : pyenv_result rescue : - name : Debug pyenv fail debug : msg : \"{{pyenv_result.stderr.split('\\n') }}\" when : pyenv_result.failed rescue pode ser traduzido como resgatar ou salvar. Dessa forma, caso alguma de nossas instala\u00e7\u00f5es do python 3.11 d\u00ea erro. Ele vai nos mostrar de forma formatada e simples o que aconteceu nessa execu\u00e7\u00e3o: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook config_python.yml TASK [ install python3.11 ] ***************************************************************** fatal: [ IP ARCH ] : FAILED! = > { \"changed\" : true, \"cmd\" : \"~/.pyenv/bin/pyenv install -s 3.11:latest\" , \"delta\" : \"0:00:03.326569\" , \"end\" : \"2022-11-16 16:03:38.101843\" , \"msg\" : \"non-zero return code\" , \"rc\" : 1 , \"start\" : \"2022-11-16 16:03:34.775274\" , \"stderr\" : \"Downloading Python-3.11.0.tar.xz...\\n-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\\nInstalling Python-3.11.0...\\n\\nBUILD FAILED (Ubuntu 20.04 using python-build 2.3.6-13-g4c261e6e)\\n\\nInspect or clean up the working tree at /tmp/python-build.20221116160334.6412\\nResults logged to /tmp/python-build.20221116160334.6412.log\\n\\nLast 10 log lines:\\nchecking for pkg-config... no\\nchecking for --enable-universalsdk... no\\nchecking for --with-universal-archs... no\\nchecking MACHDEP... \\\"linux\\\"\\nchecking for gcc... no\\nchecking for cc... no\\nchecking for cl.exe... no\\nconfigure: error: in `/tmp/python-build.20221116160334.6412/Python-3.11.0':\\nconfigure: error: no acceptable C compiler found in $PATH \\nSee `config.log' for more details\" , \"stderr_lines\" : [ \"Downloading Python-3.11.0.tar.xz...\" , \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\" , \"Installing Python-3.11.0...\" , \"\" , \"BUILD FAILED (Ubuntu 20.04 using python-build 2.3.6-13-g4c261e6e)\" , \"\" , \"Inspect or clean up the working tree at /tmp/python-build.20221116160334.6412\" , \"Results logged to /tmp/python-build.20221116160334.6412.log\" , \"\" , \"Last 10 log lines:\" , \"checking for pkg-config... no\" , \"checking for --enable-universalsdk... no\" , \"checking for --with-universal-archs... no\" , \"checking MACHDEP... \\\"linux\\\"\" , \"checking for gcc... no\" , \"checking for cc... no\" , \"checking for cl.exe... no\" , \"configure: error: in `/tmp/python-build.20221116160334.6412/Python-3.11.0':\" , \"configure: error: no acceptable C compiler found in $PATH \" , \"See `config.log' for more details\" ] , \"stdout\" : \"\" , \"stdout_lines\" : []} fatal: [ IP UBUNTU ] : FAILED! = > { \"changed\" : true, \"cmd\" : \"~/.pyenv/bin/pyenv install -s 3.11:latest\" , \"delta\" : \"0:00:04.143002\" , \"end\" : \"2022-11-16 16:03:38.885921\" , \"msg\" : \"non-zero return code\" , \"rc\" : 1 , \"start\" : \"2022-11-16 16:03:34.742919\" , \"stderr\" : \"Downloading Python-3.11.0.tar.xz...\\n-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\\nInstalling Python-3.11.0...\\n\\nBUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\\n\\nInspect or clean up the working tree at /tmp/python-build.20221116160335.2683\\nResults logged to /tmp/python-build.20221116160335.2683.log\\n\\nLast 10 log lines:\\nchecking for pkg-config... no\\nchecking for --enable-universalsdk... no\\nchecking for --with-universal-archs... no\\nchecking MACHDEP... \\\"linux\\\"\\nchecking for gcc... no\\nchecking for cc... no\\nchecking for cl.exe... no\\nconfigure: error: in `/tmp/python-build.20221116160335.2683/Python-3.11.0':\\nconfigure: error: no acceptable C compiler found in $PATH \\nSee `config.log' for more details\" , \"stderr_lines\" : [ \"Downloading Python-3.11.0.tar.xz...\" , \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\" , \"Installing Python-3.11.0...\" , \"\" , \"BUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\" , \"\" , \"Inspect or clean up the working tree at /tmp/python-build.20221116160335.2683\" , \"Results logged to /tmp/python-build.20221116160335.2683.log\" , \"\" , \"Last 10 log lines:\" , \"checking for pkg-config... no\" , \"checking for --enable-universalsdk... no\" , \"checking for --with-universal-archs... no\" , \"checking MACHDEP... \\\"linux\\\"\" , \"checking for gcc... no\" , \"checking for cc... no\" , \"checking for cl.exe... no\" , \"configure: error: in `/tmp/python-build.20221116160335.2683/Python-3.11.0':\" , \"configure: error: no acceptable C compiler found in $PATH \" , \"See `config.log' for more details\" ] , \"stdout\" : \"\" , \"stdout_lines\" : []} TASK [ Debug pyenv fail ] ******************************************************************* ok: [ IP ARCH ] = > { \"msg\" : [ \"Downloading Python-3.11.0.tar.xz...\" , \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\" , \"Installing Python-3.11.0...\" , \"\" , \"BUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\" , \"\" , \"Inspect or clean up the working tree at /tmp/python-build.20221116160335.2683\" , \"Results logged to /tmp/python-build.20221116160335.2683.log\" , \"\" , \"Last 10 log lines:\" , \"checking for pkg-config... no\" , \"checking for --enable-universalsdk... no\" , \"checking for --with-universal-archs... no\" , \"checking MACHDEP... \\\"linux\\\"\" , \"checking for gcc... no\" , \"checking for cc... no\" , \"checking for cl.exe... no\" , \"configure: error: in `/tmp/python-build.20221116160335.2683/Python-3.11.0':\" , \"configure: error: no acceptable C compiler found in $PATH \" , \"See `config.log' for more details\" ] } ok: [ IP UBUNTU ] = > { \"msg\" : [ \"Downloading Python-3.11.0.tar.xz...\" , \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\" , \"Installing Python-3.11.0...\" , \"\" , \"BUILD FAILED (Ubuntu 20.04 using python-build 2.3.6-13-g4c261e6e)\" , \"\" , \"Inspect or clean up the working tree at /tmp/python-build.20221116160334.6412\" , \"Results logged to /tmp/python-build.20221116160334.6412.log\" , \"\" , \"Last 10 log lines:\" , \"checking for pkg-config... no\" , \"checking for --enable-universalsdk... no\" , \"checking for --with-universal-archs... no\" , \"checking MACHDEP... \\\"linux\\\"\" , \"checking for gcc... no\" , \"checking for cc... no\" , \"checking for cl.exe... no\" , \"configure: error: in `/tmp/python-build.20221116160334.6412/Python-3.11.0':\" , \"configure: error: no acceptable C compiler found in $PATH \" , \"See `config.log' for more details\" ] } Com isso, conseguimos escapar do erro grande da task install python3.11 e ficamos com um erro f\u00e1cil de ser lido na task Debug pyenv fail . Nas duas respostas temos o mesmo erro. N\u00e3o existe um compilador instalado. Ent\u00e3o precisamos instalar os pacotes necess\u00e1rios para que o pyenv consiga fazer a compila\u00e7\u00e3o. Elas est\u00e3o listadas aqui e separadas por sistema operacional. Bora criar mais duas tasks para garantir que tudo funcione. Aproveitando que vamos fazer tasks condicionais. Vou aproveitar para usar os gerenciadores espec\u00edficos das distribui\u00e7\u00f5es para simplificar o processo. Para os pacotes do ubuntu, vamos usar o m\u00f3dulo do apt e para o arch vamos usar o m\u00f3dulo do pacman : config_python.yml 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 - name : Install build dependencies (ubuntu) when : ansible_distribution == 'Ubuntu' become : yes apt : update_cache : yes pkg : - make - build-essential - libssl-dev - zlib1g-dev - libbz2-dev - libreadline-dev - libsqlite3-dev - wget - curl - llvm - libncursesw5-dev - xz-utils - tk-dev - libxml2-dev - libxmlsec1-dev - libffi-dev - liblzma-dev - name : Install build dependencies (arch) when : ansible_distribution == 'Archlinux' become : yes pacman : update_cache : yes name : - base-devel - openssl - zlib - xz - tk Por contar com a instala\u00e7\u00e3o de muitos pacotes, pode demorar um pouco Voc\u00ea pode checar o arquivo todo aqui TASK [Install build dependencies (ubuntu)] ************************************************ skipping: [IP ARCH] changed: [IP UBUNTU] TASK [Install build dependencies (arch)] ************************************************** skipping: [IP UBUNTU] changed: [IP ARCH] TASK [install python3.11] ***************************************************************** fatal: [IP ARCH]: FAILED! => {\"changed\": true, \"cmd\": \"~/.pyenv/bin/pyenv install -s 3.11:latest\", \"delta\": \"0:00:03.715686\", \"end\": \"2022-11-16 16:39:52.892123\", \"msg\": \"non-zero return code\", \"rc\": 1, \"start\": \"2022-11-16 16:39:49.176437\", \"stderr\": \"Downloading Python-3.11.0.tar.xz...\\n-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\\n/home/vagrant/.pyenv/plugins/python-build/bin/python-build: line 245: pushd: write error: No space left on device\\nInstalling Python-3.11.0...\\n\\nBUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\\n\\nInspect or clean up the working tree at /tmp/python-build.20221116163949.4095\\nResults logged to /tmp/python-build.20221116163949.4095.log\\n\\nLast 10 log lines:\\ntar: Python-3.11.0/Lib/test/test___future__.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_genericpath.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/ssltests.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_random.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_signal.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/bisect_cmd.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_sysconfig.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/bad_coding2.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_codecmaps_kr.py: Cannot write: No space left on device\\ntar: Pyt\", \"stderr_lines\": [\"Downloading Python-3.11.0.tar.xz...\", \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\", \"/home/vagrant/.pyenv/plugins/python-build/bin/python-build: line 245: pushd: write error: No space left on device\", \"Installing Python-3.11.0...\", \"\", \"BUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\", \"\", \"Inspect or clean up the working tree at /tmp/python-build.20221116163949.4095\", \"Results logged to /tmp/python-build.20221116163949.4095.log\", \"\", \"Last 10 log lines:\", \"tar: Python-3.11.0/Lib/test/test___future__.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_genericpath.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/ssltests.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_random.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_signal.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/bisect_cmd.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_sysconfig.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/bad_coding2.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_codecmaps_kr.py: Cannot write: No space left on device\", \"tar: Pyt\"], \"stdout\": \"\", \"stdout_lines\": []} changed: [IP UBUNTU] TASK [Debug pyenv fail] ******************************************************************* ok: [IP ARCH] => { \"msg\": [ \"Downloading Python-3.11.0.tar.xz...\", \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\", \"/home/vagrant/.pyenv/plugins/python-build/bin/python-build: line 245: pushd: write error: No space left on device\", \"Installing Python-3.11.0...\", \"\", \"BUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\", \"\", \"Inspect or clean up the working tree at /tmp/python-build.20221116163949.4095\", \"Results logged to /tmp/python-build.20221116163949.4095.log\", \"\", \"Last 10 log lines:\", \"tar: Python-3.11.0/Lib/test/test___future__.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_genericpath.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/ssltests.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_random.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_signal.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/bisect_cmd.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_sysconfig.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/bad_coding2.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_codecmaps_kr.py: Cannot write: No space left on device\", \"tar: Pyt\" ] } Temos um erro por n\u00e3o ter espa\u00e7o em disco para compilar o 3.11 no arch. Para resolver essa quest\u00e3o clique aqui Agrupamento de tasks Agora que fizemos muitas tasks para uma instala\u00e7\u00e3o relativamente simples. Uma coisa que podemos fazer para organizar tudo \u00e9 dividir as tasks em arquivos menores e usar o m\u00f3dulo import_task . Assim podemos quebrar nosso arquiv\u00e3o para a configura\u00e7\u00e3o do pyenv em arquivos bem menores. Vamos criar um novo playbook chamado play_tasks.yaml e separar por blocos: play_tasks.yaml --- - name : Configura o ambiente de desenvolvimento hosts : linux gather_facts : true - name : Depend\u00eancias de desenvolvimento become : true import_tasks : tasks/dev_env.yml - name : Pyenv install import_tasks : tasks/pyenv.yml - name : Install python 3.11 import_tasks : tasks/py_311.yml E com isso podemos quebrar nosso grande playbook em arquivos de task: Para ver todos os arquivos tasks/dev_env.yml tasks/pyenv.yml tasks/py_311.yml - name : Install git become : yes package : name : git state : present - name : Install build dependencies (ubuntu) when : ansible_distribution == 'Ubuntu' become : yes apt : update_cache : yes pkg : - make - build-essential - libssl-dev - zlib1g-dev - libbz2-dev - libreadline-dev - libsqlite3-dev - wget - curl - llvm - libncursesw5-dev - xz-utils - tk-dev - libxml2-dev - libxmlsec1-dev - libffi-dev - liblzma-dev - name : Install build dependencies (arch) when : ansible_distribution == 'Archlinux' become : yes pacman : update_cache : yes name : - base-devel - openssl - zlib - xz - tk - name : Clone Pyenv git : repo : https://github.com/pyenv/pyenv.git dest : ~/.pyenv - name : Config pyenv blockinfile : dest : ~/.bashrc block : | echo 'export PATH=\"$HOME/.pyenv/bin:$PATH\"' >> ~/.bashrc echo 'eval \"$(pyenv init -)\"' >>~/.bashrc echo 'eval \"$(pyenv virtualenv-init -)\"' >> ~/.bashrc echo 'PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc - block : - name : install python3.11 shell : ~/.pyenv/bin/pyenv install -s 3.11:latest register : pyenv_result rescue : - name : Debug pyenv fail debug : msg : \"{{pyenv_result.stderr.split('\\n') }}\" when : pyenv_result.failed E com isso temos um entendimento um pouco mais profundo de como lidar com tasks.","title":"Tasks"},{"location":"06_tasks/#tasks","text":"Embora tenhamos usados tasks em praticamente tudo at\u00e9 aqui. Acredito que valha um momento espec\u00edfico para falar sobre elas. Pois nem sempre as coisas d\u00e3o certo e \u00e0s vezes precisamos debugar as tarefas no Ansible. Ent\u00e3o nessa parte vamos falar um pouco sobre tasks, um pouco sobre debug e um pouco sobre agrupamento de tasks.","title":"Tasks"},{"location":"06_tasks/#uma-task-qualquer","text":"Para exemplificar uma task, quero fazer com voc\u00eas a instala\u00e7\u00e3o do pyenv. Costuma dar bastante problema, pois o SSH usado pelo Ansible n\u00e3o consegue reconhecer o .bashrc Para come\u00e7ar, vamos instalar o git e fazer o clone do pyenv: config_python.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- - name : Configura\u00e7\u00e3o do ambiente python hosts : linux tasks : - name : Install git become : yes package : name : git state : present - name : Clone Pyenv git : repo : https://github.com/pyenv/pyenv.git dest : ~/.pyenv Por\u00e9m, a configura\u00e7\u00e3o do pyenv depende de que o arquivo ./bashrc seja modificado para que o pyenv funcione de fato. Ent\u00e3o agora vamos aprender mais um m\u00f3dulo. O m\u00f3dulo blockinfile . Ele permite que adicionemos um bloco de texto em um arquivo qualquer: config_python.yml 17 18 19 20 21 22 23 24 - name : config pyenv blockinfile : dest : ~/.bashrc block : | echo 'export PATH=\"$HOME/.pyenv/bin:$PATH\"' >> ~/.bashrc echo 'eval \"$(pyenv init -)\"' >>~/.bashrc echo 'eval \"$(pyenv virtualenv-init -)\"' >> ~/.bashrc echo 'PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc","title":"Uma task qualquer"},{"location":"06_tasks/#register","text":"Vamos supor que queremos checar o que est\u00e1 escrito dentro do arquivo .bashrc para saber se ele est\u00e1 escrito da maneira correta. Para isso vamos criar mais uma task. Para isso vamos usar o m\u00f3dulo shell e tamb\u00e9m a funcionalidade de registro em vari\u00e1veis do ansible: config_python.yml 27 28 29 - name : Show bashrc shell : cat ~/.bashrc register : bashrc Dessa forma, por termos chamado register o ansible vai armazenar o resultado da tarefa Show bashrc na vari\u00e1vel bashrc . E podemos acessar ela usando o m\u00f3dulo de debug : config_python.yml 30 31 32 - name : Checking bashrc debug : msg : \"{{ bashrc.stdout.split('\\n') }}\" Quando o playbook for executado, nos mostrar\u00e1 de maneira formatada o stdout da tarefa Show bashrc : $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook config_python.yml TASK [ Show bashrc ] ******************************************************************************* changed: [ IP ] TASK [ Checking bashrc ] ******************************************************************** ok: [ IP ] = > { \"msg\" : [ \"#\" , \"# ~/.bashrc\" , \"#\" , \"\" , \"# If not running interactively, don't do anything\" , \"[[ $- != *i* ]] && return\" , \"\" , \"alias ls='ls --color=auto'\" , \"PS1='[\\\\u@\\\\h \\\\W]\\\\ $ '\" , \"# BEGIN ANSIBLE MANAGED BLOCK\" , \"echo 'export PATH=\\\" $HOME /.pyenv/bin: $PATH \\\"' >> ~/.bashrc\" , \"echo 'eval \\\" $( pyenv init - ) \\\"' >>~/.bashrc\" , \"echo 'eval \\\" $( pyenv virtualenv-init - ) \\\"' >> ~/.bashrc\" , \"echo 'PATH=\\\" $HOME /.local/bin: $PATH \\\"' >> ~/.bashrc\" , \"# END ANSIBLE MANAGED BLOCK\" ] } O que significa que conseguimos chamar o debug. Por\u00e9m, em alguns momentos as tasks podem e v\u00e3o dar errado. Ent\u00e3o precisamos entender como prosseguir, caso isso aconte\u00e7a.","title":"Register"},{"location":"06_tasks/#debug-de-tasks","text":"Vamos executar uma a\u00e7\u00e3o que tenho certeza que vai dar erro por conta das configura\u00e7\u00f5es que fizemos at\u00e9 agora para entender como podemos checar as mensagens de erro. Em teoria, se temos o pyenv instalado, podemos pedir para que ele instale a vers\u00e3o 3.11 do python: config_python.yml 34 35 36 37 - block : - name : install python3.11 shell : pyenv install -s 3.11:latest register : pyenv_result Note que inseri um bloco no playbook chamado block . Ele nos ajuda a executar uma tarefa na sequ\u00eancia caso uma delas d\u00ea erro. E para isso vamos adicionar um par\u00e2metro para esse bloco chamado rescue . Ficando com esse bloco: config_python.yml 34 35 36 37 38 39 40 41 42 - block : - name : install python3.11 shell : pyenv install -s 3.11:latest register : pyenv_result rescue : - name : Debug pyenv fail debug : msg : \"{{pyenv_result.stderr.split('\\n') }}\" when : pyenv_result.failed rescue pode ser traduzido como resgatar ou salvar. Dessa forma, caso alguma de nossas instala\u00e7\u00f5es do python 3.11 d\u00ea erro. Ele vai nos mostrar de forma formatada e simples o que aconteceu nessa execu\u00e7\u00e3o: $ Execu\u00e7\u00e3o no terminal e a parte importante do resultado ansible-playbook config_python.yml TASK [ install python3.11 ] ***************************************************************** fatal: [ IP ARCH ] : FAILED! = > { \"changed\" : true, \"cmd\" : \"~/.pyenv/bin/pyenv install -s 3.11:latest\" , \"delta\" : \"0:00:03.326569\" , \"end\" : \"2022-11-16 16:03:38.101843\" , \"msg\" : \"non-zero return code\" , \"rc\" : 1 , \"start\" : \"2022-11-16 16:03:34.775274\" , \"stderr\" : \"Downloading Python-3.11.0.tar.xz...\\n-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\\nInstalling Python-3.11.0...\\n\\nBUILD FAILED (Ubuntu 20.04 using python-build 2.3.6-13-g4c261e6e)\\n\\nInspect or clean up the working tree at /tmp/python-build.20221116160334.6412\\nResults logged to /tmp/python-build.20221116160334.6412.log\\n\\nLast 10 log lines:\\nchecking for pkg-config... no\\nchecking for --enable-universalsdk... no\\nchecking for --with-universal-archs... no\\nchecking MACHDEP... \\\"linux\\\"\\nchecking for gcc... no\\nchecking for cc... no\\nchecking for cl.exe... no\\nconfigure: error: in `/tmp/python-build.20221116160334.6412/Python-3.11.0':\\nconfigure: error: no acceptable C compiler found in $PATH \\nSee `config.log' for more details\" , \"stderr_lines\" : [ \"Downloading Python-3.11.0.tar.xz...\" , \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\" , \"Installing Python-3.11.0...\" , \"\" , \"BUILD FAILED (Ubuntu 20.04 using python-build 2.3.6-13-g4c261e6e)\" , \"\" , \"Inspect or clean up the working tree at /tmp/python-build.20221116160334.6412\" , \"Results logged to /tmp/python-build.20221116160334.6412.log\" , \"\" , \"Last 10 log lines:\" , \"checking for pkg-config... no\" , \"checking for --enable-universalsdk... no\" , \"checking for --with-universal-archs... no\" , \"checking MACHDEP... \\\"linux\\\"\" , \"checking for gcc... no\" , \"checking for cc... no\" , \"checking for cl.exe... no\" , \"configure: error: in `/tmp/python-build.20221116160334.6412/Python-3.11.0':\" , \"configure: error: no acceptable C compiler found in $PATH \" , \"See `config.log' for more details\" ] , \"stdout\" : \"\" , \"stdout_lines\" : []} fatal: [ IP UBUNTU ] : FAILED! = > { \"changed\" : true, \"cmd\" : \"~/.pyenv/bin/pyenv install -s 3.11:latest\" , \"delta\" : \"0:00:04.143002\" , \"end\" : \"2022-11-16 16:03:38.885921\" , \"msg\" : \"non-zero return code\" , \"rc\" : 1 , \"start\" : \"2022-11-16 16:03:34.742919\" , \"stderr\" : \"Downloading Python-3.11.0.tar.xz...\\n-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\\nInstalling Python-3.11.0...\\n\\nBUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\\n\\nInspect or clean up the working tree at /tmp/python-build.20221116160335.2683\\nResults logged to /tmp/python-build.20221116160335.2683.log\\n\\nLast 10 log lines:\\nchecking for pkg-config... no\\nchecking for --enable-universalsdk... no\\nchecking for --with-universal-archs... no\\nchecking MACHDEP... \\\"linux\\\"\\nchecking for gcc... no\\nchecking for cc... no\\nchecking for cl.exe... no\\nconfigure: error: in `/tmp/python-build.20221116160335.2683/Python-3.11.0':\\nconfigure: error: no acceptable C compiler found in $PATH \\nSee `config.log' for more details\" , \"stderr_lines\" : [ \"Downloading Python-3.11.0.tar.xz...\" , \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\" , \"Installing Python-3.11.0...\" , \"\" , \"BUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\" , \"\" , \"Inspect or clean up the working tree at /tmp/python-build.20221116160335.2683\" , \"Results logged to /tmp/python-build.20221116160335.2683.log\" , \"\" , \"Last 10 log lines:\" , \"checking for pkg-config... no\" , \"checking for --enable-universalsdk... no\" , \"checking for --with-universal-archs... no\" , \"checking MACHDEP... \\\"linux\\\"\" , \"checking for gcc... no\" , \"checking for cc... no\" , \"checking for cl.exe... no\" , \"configure: error: in `/tmp/python-build.20221116160335.2683/Python-3.11.0':\" , \"configure: error: no acceptable C compiler found in $PATH \" , \"See `config.log' for more details\" ] , \"stdout\" : \"\" , \"stdout_lines\" : []} TASK [ Debug pyenv fail ] ******************************************************************* ok: [ IP ARCH ] = > { \"msg\" : [ \"Downloading Python-3.11.0.tar.xz...\" , \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\" , \"Installing Python-3.11.0...\" , \"\" , \"BUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\" , \"\" , \"Inspect or clean up the working tree at /tmp/python-build.20221116160335.2683\" , \"Results logged to /tmp/python-build.20221116160335.2683.log\" , \"\" , \"Last 10 log lines:\" , \"checking for pkg-config... no\" , \"checking for --enable-universalsdk... no\" , \"checking for --with-universal-archs... no\" , \"checking MACHDEP... \\\"linux\\\"\" , \"checking for gcc... no\" , \"checking for cc... no\" , \"checking for cl.exe... no\" , \"configure: error: in `/tmp/python-build.20221116160335.2683/Python-3.11.0':\" , \"configure: error: no acceptable C compiler found in $PATH \" , \"See `config.log' for more details\" ] } ok: [ IP UBUNTU ] = > { \"msg\" : [ \"Downloading Python-3.11.0.tar.xz...\" , \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\" , \"Installing Python-3.11.0...\" , \"\" , \"BUILD FAILED (Ubuntu 20.04 using python-build 2.3.6-13-g4c261e6e)\" , \"\" , \"Inspect or clean up the working tree at /tmp/python-build.20221116160334.6412\" , \"Results logged to /tmp/python-build.20221116160334.6412.log\" , \"\" , \"Last 10 log lines:\" , \"checking for pkg-config... no\" , \"checking for --enable-universalsdk... no\" , \"checking for --with-universal-archs... no\" , \"checking MACHDEP... \\\"linux\\\"\" , \"checking for gcc... no\" , \"checking for cc... no\" , \"checking for cl.exe... no\" , \"configure: error: in `/tmp/python-build.20221116160334.6412/Python-3.11.0':\" , \"configure: error: no acceptable C compiler found in $PATH \" , \"See `config.log' for more details\" ] } Com isso, conseguimos escapar do erro grande da task install python3.11 e ficamos com um erro f\u00e1cil de ser lido na task Debug pyenv fail . Nas duas respostas temos o mesmo erro. N\u00e3o existe um compilador instalado. Ent\u00e3o precisamos instalar os pacotes necess\u00e1rios para que o pyenv consiga fazer a compila\u00e7\u00e3o. Elas est\u00e3o listadas aqui e separadas por sistema operacional. Bora criar mais duas tasks para garantir que tudo funcione. Aproveitando que vamos fazer tasks condicionais. Vou aproveitar para usar os gerenciadores espec\u00edficos das distribui\u00e7\u00f5es para simplificar o processo. Para os pacotes do ubuntu, vamos usar o m\u00f3dulo do apt e para o arch vamos usar o m\u00f3dulo do pacman : config_python.yml 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 - name : Install build dependencies (ubuntu) when : ansible_distribution == 'Ubuntu' become : yes apt : update_cache : yes pkg : - make - build-essential - libssl-dev - zlib1g-dev - libbz2-dev - libreadline-dev - libsqlite3-dev - wget - curl - llvm - libncursesw5-dev - xz-utils - tk-dev - libxml2-dev - libxmlsec1-dev - libffi-dev - liblzma-dev - name : Install build dependencies (arch) when : ansible_distribution == 'Archlinux' become : yes pacman : update_cache : yes name : - base-devel - openssl - zlib - xz - tk Por contar com a instala\u00e7\u00e3o de muitos pacotes, pode demorar um pouco Voc\u00ea pode checar o arquivo todo aqui TASK [Install build dependencies (ubuntu)] ************************************************ skipping: [IP ARCH] changed: [IP UBUNTU] TASK [Install build dependencies (arch)] ************************************************** skipping: [IP UBUNTU] changed: [IP ARCH] TASK [install python3.11] ***************************************************************** fatal: [IP ARCH]: FAILED! => {\"changed\": true, \"cmd\": \"~/.pyenv/bin/pyenv install -s 3.11:latest\", \"delta\": \"0:00:03.715686\", \"end\": \"2022-11-16 16:39:52.892123\", \"msg\": \"non-zero return code\", \"rc\": 1, \"start\": \"2022-11-16 16:39:49.176437\", \"stderr\": \"Downloading Python-3.11.0.tar.xz...\\n-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\\n/home/vagrant/.pyenv/plugins/python-build/bin/python-build: line 245: pushd: write error: No space left on device\\nInstalling Python-3.11.0...\\n\\nBUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\\n\\nInspect or clean up the working tree at /tmp/python-build.20221116163949.4095\\nResults logged to /tmp/python-build.20221116163949.4095.log\\n\\nLast 10 log lines:\\ntar: Python-3.11.0/Lib/test/test___future__.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_genericpath.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/ssltests.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_random.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_signal.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/bisect_cmd.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_sysconfig.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/bad_coding2.py: Cannot write: No space left on device\\ntar: Python-3.11.0/Lib/test/test_codecmaps_kr.py: Cannot write: No space left on device\\ntar: Pyt\", \"stderr_lines\": [\"Downloading Python-3.11.0.tar.xz...\", \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\", \"/home/vagrant/.pyenv/plugins/python-build/bin/python-build: line 245: pushd: write error: No space left on device\", \"Installing Python-3.11.0...\", \"\", \"BUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\", \"\", \"Inspect or clean up the working tree at /tmp/python-build.20221116163949.4095\", \"Results logged to /tmp/python-build.20221116163949.4095.log\", \"\", \"Last 10 log lines:\", \"tar: Python-3.11.0/Lib/test/test___future__.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_genericpath.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/ssltests.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_random.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_signal.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/bisect_cmd.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_sysconfig.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/bad_coding2.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_codecmaps_kr.py: Cannot write: No space left on device\", \"tar: Pyt\"], \"stdout\": \"\", \"stdout_lines\": []} changed: [IP UBUNTU] TASK [Debug pyenv fail] ******************************************************************* ok: [IP ARCH] => { \"msg\": [ \"Downloading Python-3.11.0.tar.xz...\", \"-> https://www.python.org/ftp/python/3.11.0/Python-3.11.0.tar.xz\", \"/home/vagrant/.pyenv/plugins/python-build/bin/python-build: line 245: pushd: write error: No space left on device\", \"Installing Python-3.11.0...\", \"\", \"BUILD FAILED (Arch Linux using python-build 2.3.6-13-g4c261e6e)\", \"\", \"Inspect or clean up the working tree at /tmp/python-build.20221116163949.4095\", \"Results logged to /tmp/python-build.20221116163949.4095.log\", \"\", \"Last 10 log lines:\", \"tar: Python-3.11.0/Lib/test/test___future__.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_genericpath.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/ssltests.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_random.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_signal.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/bisect_cmd.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_sysconfig.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/bad_coding2.py: Cannot write: No space left on device\", \"tar: Python-3.11.0/Lib/test/test_codecmaps_kr.py: Cannot write: No space left on device\", \"tar: Pyt\" ] } Temos um erro por n\u00e3o ter espa\u00e7o em disco para compilar o 3.11 no arch. Para resolver essa quest\u00e3o clique aqui","title":"Debug de tasks"},{"location":"06_tasks/#agrupamento-de-tasks","text":"Agora que fizemos muitas tasks para uma instala\u00e7\u00e3o relativamente simples. Uma coisa que podemos fazer para organizar tudo \u00e9 dividir as tasks em arquivos menores e usar o m\u00f3dulo import_task . Assim podemos quebrar nosso arquiv\u00e3o para a configura\u00e7\u00e3o do pyenv em arquivos bem menores. Vamos criar um novo playbook chamado play_tasks.yaml e separar por blocos: play_tasks.yaml --- - name : Configura o ambiente de desenvolvimento hosts : linux gather_facts : true - name : Depend\u00eancias de desenvolvimento become : true import_tasks : tasks/dev_env.yml - name : Pyenv install import_tasks : tasks/pyenv.yml - name : Install python 3.11 import_tasks : tasks/py_311.yml E com isso podemos quebrar nosso grande playbook em arquivos de task: Para ver todos os arquivos tasks/dev_env.yml tasks/pyenv.yml tasks/py_311.yml - name : Install git become : yes package : name : git state : present - name : Install build dependencies (ubuntu) when : ansible_distribution == 'Ubuntu' become : yes apt : update_cache : yes pkg : - make - build-essential - libssl-dev - zlib1g-dev - libbz2-dev - libreadline-dev - libsqlite3-dev - wget - curl - llvm - libncursesw5-dev - xz-utils - tk-dev - libxml2-dev - libxmlsec1-dev - libffi-dev - liblzma-dev - name : Install build dependencies (arch) when : ansible_distribution == 'Archlinux' become : yes pacman : update_cache : yes name : - base-devel - openssl - zlib - xz - tk - name : Clone Pyenv git : repo : https://github.com/pyenv/pyenv.git dest : ~/.pyenv - name : Config pyenv blockinfile : dest : ~/.bashrc block : | echo 'export PATH=\"$HOME/.pyenv/bin:$PATH\"' >> ~/.bashrc echo 'eval \"$(pyenv init -)\"' >>~/.bashrc echo 'eval \"$(pyenv virtualenv-init -)\"' >> ~/.bashrc echo 'PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc - block : - name : install python3.11 shell : ~/.pyenv/bin/pyenv install -s 3.11:latest register : pyenv_result rescue : - name : Debug pyenv fail debug : msg : \"{{pyenv_result.stderr.split('\\n') }}\" when : pyenv_result.failed E com isso temos um entendimento um pouco mais profundo de como lidar com tasks.","title":"Agrupamento de tasks"},{"location":"07_ansible_galaxy/","text":"Ansible Galaxy Como vimos, o nome Ansible vem da hist\u00f3ria do mundo de Rocannon na hist\u00f3ria de Ursula K. Le Guin. Rocannon \u00e9 um antrop\u00f3logo que precisa se comunicar com outros planetas usando o Ansible. O Ansible Galaxy \u00e9 uma forma de compartilhar receitas com outras pessoas usando Ansible. Voc\u00ea pode acessar o Galaxy nesse link Existem diversas receitas e m\u00f3dulos prontos e feitos pela comunidade que podemos explorar e instalar em nosso n\u00f3 controlador para automatizar tarefas de forma mais eficiente. Instalando um m\u00f3dulo Uma coisa que gosto bastante no meu ambiente pessoal \u00e9 de instalar diversas vers\u00f5es do python. Isso me ajuda a trabalhar melhor e testar c\u00f3digo em diversas vers\u00f5es do python. O Ansible, por\u00e9m, n\u00e3o conta com um m\u00f3dulo nativo para lidar como o pyenv que \u00e9 um instalador de vers\u00f5es do python. Para isso, podemos contar com o Galaxy. Uma pessoa da comunidade criou um pacote para gerenciar o pyenv . Para instalar essa role temos que o usar o comando ansible-galaxy : $ Execu\u00e7\u00e3o no terminal ansible-galaxy install staticdev.pyenv staticdev \u00e9 o nome do perfil da pessoa que criou o pacote para o galaxy Resposta do terminal Starting galaxy role install process - downloading role 'pyenv' , owned by staticdev - downloading role from https://github.com/staticdev/ansible-role-pyenv/archive/2.6.2.tar.gz - extracting staticdev.pyenv to /home/vagrant/.ansible/roles/staticdev.pyenv - staticdev.pyenv ( 2 .6.2 ) was installed successfully Usando o m\u00f3dulo Agora que temos a role do pyenv podemos incorporar ela em nossos playbooks. Vamos reescrever as tasks que instalam e configuram o pyenv. Pois tudo aqui \u00e9 feito de forma automatizada: play_tasks.yaml --- - name : Configura o ambiente de desenvolvimento hosts : linux gather_facts : true tasks : - name : Depend\u00eancias de desenvolvimento become : true import_tasks : tasks/dev_env.yml roles : - role : staticdev.pyenv pyenv_env : user pyenv_global : - 3.11.0 pyenv_python_versions : - 3.11.0 Role vs Task vs Collection! Task: Tasks s\u00e3o implemente tarefas, j\u00e1 vimos muitas por hoje Role: Roles podem conter diversas tasks, arquivos, vari\u00e1veis pr\u00f3prias e diversos outros artefatos Collection: Cole\u00e7\u00f5es podem conter playbooks, roles, m\u00f3dulos e plugins requirements de Collections e Rules Tamb\u00e9m podemos centralizar um arquivo com todas as nossas depend\u00eancias. Para que seja mais simples o processo de instala\u00e7\u00e3o dos pacotes de terceiros do Galaxy. Vou chamar esse arquivo de requirements.yml . Nele vamos instalar um gerenciador de pacotes para o arch poder baixar pacotes do reposit\u00f3rio AUR . Que vem em uma cole\u00e7\u00e3o chamada kewlfft.aur e tamb\u00e9m vamos deixar a role do pyenv para ficar num arquivo \u00fanico e centralizado: requirements.yml collections : - name : kewlfft.aur roles : - name : staticdev.pyenv Agora com esse arquivo podemos instalar todas as collections de uma vez: $ Execu\u00e7\u00e3o no terminal ansible-galaxy collection install -r requirements.yml E tamb\u00e9m podemos instalar todas as roles de uma vez s\u00f3: $ Execu\u00e7\u00e3o no terminal ansible-galaxy role install -r requirements.yml Dessa forma ficando mais simples de compartilhar nosso ambiente Ansible com outras pessoas","title":"Ansible Galaxy"},{"location":"07_ansible_galaxy/#ansible-galaxy","text":"Como vimos, o nome Ansible vem da hist\u00f3ria do mundo de Rocannon na hist\u00f3ria de Ursula K. Le Guin. Rocannon \u00e9 um antrop\u00f3logo que precisa se comunicar com outros planetas usando o Ansible. O Ansible Galaxy \u00e9 uma forma de compartilhar receitas com outras pessoas usando Ansible. Voc\u00ea pode acessar o Galaxy nesse link Existem diversas receitas e m\u00f3dulos prontos e feitos pela comunidade que podemos explorar e instalar em nosso n\u00f3 controlador para automatizar tarefas de forma mais eficiente.","title":"Ansible Galaxy"},{"location":"07_ansible_galaxy/#instalando-um-modulo","text":"Uma coisa que gosto bastante no meu ambiente pessoal \u00e9 de instalar diversas vers\u00f5es do python. Isso me ajuda a trabalhar melhor e testar c\u00f3digo em diversas vers\u00f5es do python. O Ansible, por\u00e9m, n\u00e3o conta com um m\u00f3dulo nativo para lidar como o pyenv que \u00e9 um instalador de vers\u00f5es do python. Para isso, podemos contar com o Galaxy. Uma pessoa da comunidade criou um pacote para gerenciar o pyenv . Para instalar essa role temos que o usar o comando ansible-galaxy : $ Execu\u00e7\u00e3o no terminal ansible-galaxy install staticdev.pyenv staticdev \u00e9 o nome do perfil da pessoa que criou o pacote para o galaxy Resposta do terminal Starting galaxy role install process - downloading role 'pyenv' , owned by staticdev - downloading role from https://github.com/staticdev/ansible-role-pyenv/archive/2.6.2.tar.gz - extracting staticdev.pyenv to /home/vagrant/.ansible/roles/staticdev.pyenv - staticdev.pyenv ( 2 .6.2 ) was installed successfully","title":"Instalando um m\u00f3dulo"},{"location":"07_ansible_galaxy/#usando-o-modulo","text":"Agora que temos a role do pyenv podemos incorporar ela em nossos playbooks. Vamos reescrever as tasks que instalam e configuram o pyenv. Pois tudo aqui \u00e9 feito de forma automatizada: play_tasks.yaml --- - name : Configura o ambiente de desenvolvimento hosts : linux gather_facts : true tasks : - name : Depend\u00eancias de desenvolvimento become : true import_tasks : tasks/dev_env.yml roles : - role : staticdev.pyenv pyenv_env : user pyenv_global : - 3.11.0 pyenv_python_versions : - 3.11.0","title":"Usando o m\u00f3dulo"},{"location":"07_ansible_galaxy/#role-vs-task-vs-collection","text":"Task: Tasks s\u00e3o implemente tarefas, j\u00e1 vimos muitas por hoje Role: Roles podem conter diversas tasks, arquivos, vari\u00e1veis pr\u00f3prias e diversos outros artefatos Collection: Cole\u00e7\u00f5es podem conter playbooks, roles, m\u00f3dulos e plugins","title":"Role vs Task vs Collection!"},{"location":"07_ansible_galaxy/#requirements-de-collections-e-rules","text":"Tamb\u00e9m podemos centralizar um arquivo com todas as nossas depend\u00eancias. Para que seja mais simples o processo de instala\u00e7\u00e3o dos pacotes de terceiros do Galaxy. Vou chamar esse arquivo de requirements.yml . Nele vamos instalar um gerenciador de pacotes para o arch poder baixar pacotes do reposit\u00f3rio AUR . Que vem em uma cole\u00e7\u00e3o chamada kewlfft.aur e tamb\u00e9m vamos deixar a role do pyenv para ficar num arquivo \u00fanico e centralizado: requirements.yml collections : - name : kewlfft.aur roles : - name : staticdev.pyenv Agora com esse arquivo podemos instalar todas as collections de uma vez: $ Execu\u00e7\u00e3o no terminal ansible-galaxy collection install -r requirements.yml E tamb\u00e9m podemos instalar todas as roles de uma vez s\u00f3: $ Execu\u00e7\u00e3o no terminal ansible-galaxy role install -r requirements.yml Dessa forma ficando mais simples de compartilhar nosso ambiente Ansible com outras pessoas","title":"requirements de Collections e Rules"},{"location":"99_problemas_comuns/","text":"Alguns problemas que podem acontecer Sem espa\u00e7o no disco Caso seu disco fique sem espa\u00e7o, voc\u00ea pode mudar a configura\u00e7\u00e3o do Vagrantile para aumentar o tamanho do disco config . vm . define \"arch\" do | arch | arch . vm . box = \"archlinux/archlinux\" arch . disksize . size = \"30GB\" arch . vm . provider \"virtualbox\" do | vb | vb . memory = \"1024\" end O Vagrant, por\u00e9m, n\u00e3o consegue executar essa tarefa. Para que isso seja feito, voc\u00ea precisa instalar uma extens\u00e3o no Vagrant: $ Execu\u00e7\u00e3o no terminal vagrant plugin install vagrant-disksize Em seguida, voc\u00ea pode reiniciar a vm: $ Execu\u00e7\u00e3o no terminal vagrant reload <m\u00e1quina>","title":"Alguns problemas que podem acontecer"},{"location":"99_problemas_comuns/#alguns-problemas-que-podem-acontecer","text":"","title":"Alguns problemas que podem acontecer"},{"location":"99_problemas_comuns/#sem-espaco-no-disco","text":"Caso seu disco fique sem espa\u00e7o, voc\u00ea pode mudar a configura\u00e7\u00e3o do Vagrantile para aumentar o tamanho do disco config . vm . define \"arch\" do | arch | arch . vm . box = \"archlinux/archlinux\" arch . disksize . size = \"30GB\" arch . vm . provider \"virtualbox\" do | vb | vb . memory = \"1024\" end O Vagrant, por\u00e9m, n\u00e3o consegue executar essa tarefa. Para que isso seja feito, voc\u00ea precisa instalar uma extens\u00e3o no Vagrant: $ Execu\u00e7\u00e3o no terminal vagrant plugin install vagrant-disksize Em seguida, voc\u00ea pode reiniciar a vm: $ Execu\u00e7\u00e3o no terminal vagrant reload <m\u00e1quina>","title":"Sem espa\u00e7o no disco"},{"location":"referencias/","text":"Refer\u00eancias Documenta\u00e7\u00e3o do Ansible Documenta\u00e7\u00e3o do Pacman Documenta\u00e7\u00e3o do Vagrant Pergunta sobre redimensionamento de disco no Vagrant (Stackoverflow)","title":"Refer\u00eancias"},{"location":"referencias/#referencias","text":"Documenta\u00e7\u00e3o do Ansible Documenta\u00e7\u00e3o do Pacman Documenta\u00e7\u00e3o do Vagrant Pergunta sobre redimensionamento de disco no Vagrant (Stackoverflow)","title":"Refer\u00eancias"}]}